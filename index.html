<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wall Simulateur 3d</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #ffffff; color: #000000; font-family: Arial, sans-serif; }
    canvas { width: 100%; height: 100vh; }
    .toolbox, .layerbox, .actions, .brick-counter, .title, .version, .title-input { position: absolute; background: #e2e8f0; padding: 8px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); z-index: 10; }
    .toolbox { top: 10px; left: 10px; width: 256px; }
    .layerbox { top: 160px; left: 50%; transform: translateX(-50%); cursor: move; width: auto; max-width: 600px; display: flex; flex-direction: column; align-items: center; gap: 8px; pointer-events: none; }
    .layerbox * { pointer-events: auto; }
    .actions { top: 10px; right: 10px; width: 256px; }
    .brick-counter { bottom: 10px; right: 10px; width: 200px; }
    .title { top: 10px; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; }
    .title h1 { font-size: 24px; margin: 0; }
    .title p { font-size: 14px; margin: 4px 0 0; }
    .title-input { top: 80px; left: 50%; transform: translateX(-50%); width: 300px; cursor: move; pointer-events: none; }
    .title-input * { pointer-events: auto; }
    .version { bottom: 10px; left: 10px; font-size: 12px; padding: 8px; }
    button { padding: 4px; border-radius: 4px; border: none; cursor: pointer; font-size: 12px; font-weight: bold; color: #000000; }
    button:hover { opacity: 0.8; }
    .delete-active { background-color: #b7791f !important; }
    input, select { background: #edf2f7; color: #000000; border: none; padding: 4px; border-radius: 4px; width: 100%; }
    label { font-size: 14px; margin-bottom: 4px; display: block; }
    h2 { font-size: 18px; margin-bottom: 8px; color: #000000; }
    .brick-type-count { font-size: 14px; }
    .checkbox-container { margin-top: 8px; }
    .checkbox-container input[type="checkbox"] { margin-right: 8px; vertical-align: middle; }
    .checkbox-container span { font-size: 14px; vertical-align: middle; }
    #homepage { display: flex; }
    #app { display: none; }
    #notification { display: none; }
  </style>
</head>
<body>
  <div id="notification" class="absolute bg-red-600 text-white px-4 py-2 rounded-lg" style="display: none; z-index: 20;"></div>
  <div id="homepage" class="flex flex-col items-center justify-center h-screen">
    <h1 class="text-5xl font-bold text-black">Wall Simulateur 3d</h1>
    <p class="text-lg text-black mt-2">Made by Julien BROHEZ</p>
    <p class="text-lg text-black mt-2">Version 1.0.0</p>
    <button id="start-button" class="mt-6 bg-green-600 text-white px-6 py-3 text-lg rounded-lg hover:bg-green-700 transition">Commencer</button>
  </div>
  <div id="app">
    <div id="title" class="title">
      <h1>Wall Simulateur 3d</h1>
      <p>Cr√©√© par Julien BROHEZ</p>
    </div>
    <div id="title-input" class="title-input">
      <label for="project-title">Titre du projet</label>
      <input type="text" id="project-title" maxlength="100" placeholder="Entrez le titre du projet">
    </div>
    <div id="toolbox" class="toolbox">
      <h2>üß± Outils de pose</h2>
      <label for="brick-type">Type de brique/bloc</label>
      <select id="brick-type">
        <option value="M50">Brique M50</option>
        <option value="M57">Brique M57</option>
        <option value="M65">Brique M65</option>
        <option value="M90">Brique M90</option>
        <option value="WF">Brique WF</option>
        <option value="WFD">Brique WFD</option>
        <option value="Bloc9">Bloc de 9</option>
        <option value="Bloc14">Bloc de 14</option>
        <option value="Bloc19">Bloc de 19</option>
        <option value="Bloc29">Bloc de 29</option>
      </select>
      <label for="brick-size">Taille</label>
      <select id="brick-size">
        <option value="entire">Enti√®re</option>
        <option value="three_quarter">Trois quarts</option>
        <option value="half">Demi</option>
        <option value="quarter">Quart</option>
      </select>
      <label>Rotation Y (¬∞)</label>
      <input type="range" id="rotation-y" min="0" max="355" step="15" value="0">
      <div id="rotation-value" style="text-align: center; font-size: 12px;">0¬∞</div>
      <label>√âpaisseur du joint (cm)</label>
      <input type="number" id="joint-thickness" min="0" step="0.1" value="1">
      <div class="checkbox-container">
        <input type="checkbox" id="white-bricks">
        <span>Afficher en blanc</span>
      </div>
      <div class="checkbox-container">
        <input type="checkbox" id="show-grid">
        <span>Afficher la grille</span>
      </div>
      <button id="delete-mode" style="background-color: #d69e2e; margin-top: 8px;">üóëÔ∏è Effacer</button>
    </div>
    <div id="layerbox" class="layerbox">
      <div style="display: flex; align-items: center; gap: 12px;">
        <label>Assise active</label>
        <select id="layer-select"></select>
        <button id="add-layer" style="background-color: #3182ce;">‚ûï</button>
      </div>
    </div>
    <div class="actions">
      <h2>üìÑ Actions</h2>
      <button id="undo" style="background-color: #e53e3e;">‚Ü©Ô∏è Annuler</button>
      <button id="redo" style="background-color: #e53e3e; margin-top: 8px;">‚Ü™Ô∏è Refaire</button>
      <button id="save-file" style="background-color: #38a169; margin-top: 8px;">üíæ Enregistrer</button>
      <button id="open-file" style="background-color: #3182ce; margin-top: 8px;">üìÇ Ouvrir</button>
      <input type="file" id="file-input" accept=".json" style="display: none;">
      <button id="export-pdf" style="background-color: #38a169; margin-top: 8px;">üìÑ Exporter PDF</button>
      <button id="export-png" style="background-color: #3182ce; margin-top: 8px;">üñºÔ∏è Exporter PNG</button>
    </div>
    <div id="brick-counter" class="brick-counter">
      <h2>üßÆ Compteur d'√©l√©ments</h2>
      <div id="brick-type-counts" class="brick-type-count"></div>
    </div>
    <div id="version" class="version">Version 1.0.0</div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    const { jsPDF } = window.jspdf;

    // Constants
    const BRICK_SIZES = {
      M50_entire: [0.19, 0.05, 0.09],
      M50_three_quarter: [0.14, 0.05, 0.09],
      M50_half: [0.09, 0.05, 0.09],
      M50_quarter: [0.04, 0.05, 0.09],
      M57_entire: [0.19, 0.057, 0.09],
      M57_three_quarter: [0.14, 0.057, 0.09],
      M57_half: [0.09, 0.057, 0.09],
      M57_quarter: [0.04, 0.057, 0.09],
      M65_entire: [0.19, 0.065, 0.09],
      M65_three_quarter: [0.14, 0.065, 0.09],
      M65_half: [0.09, 0.065, 0.09],
      M65_quarter: [0.04, 0.065, 0.09],
      M90_entire: [0.19, 0.09, 0.09],
      M90_three_quarter: [0.14, 0.09, 0.09],
      M90_half: [0.09, 0.09, 0.09],
      M90_quarter: [0.04, 0.09, 0.09],
      WF_entire: [0.21, 0.09, 0.09],
      WF_three_quarter: [0.15, 0.05, 0.09],
      WF_half: [0.10, 0.05, 0.09],
      WF_quarter: [0.05, 0.05, 0.09],
      WFD_entire: [0.21, 0.09, 0.09],
      WFD_three_quarter: [0.15, 0.05, 0.09],
      WFD_half: [0.10, 0.05, 0.09],
      WFD_quarter: [0.05, 0.05, 0.09],
      Bloc9_entire: [0.39, 0.19, 0.09],
      Bloc9_three_quarter: [0.29, 0.19, 0.09],
      Bloc9_half: [0.19, 0.19, 0.09],
      Bloc9_quarter: [0.14, 0.19, 0.09],
      Bloc14_entire: [0.39, 0.19, 0.14],
      Bloc14_three_quarter: [0.29, 0.19, 0.14],
      Bloc14_half: [0.19, 0.19, 0.14],
      Bloc14_quarter: [0.14, 0.19, 0.14],
      Bloc19_entire: [0.39, 0.19, 0.19],
      Bloc19_three_quarter: [0.29, 0.19, 0.19],
      Bloc19_half: [0.19, 0.19, 0.19],
      Bloc19_quarter: [0.14, 0.19, 0.19],
      Bloc29_entire: [0.39, 0.19, 0.29],
      Bloc29_three_quarter: [0.29, 0.19, 0.29],
      Bloc29_half: [0.19, 0.19, 0.29],
      Bloc29_quarter: [0.14, 0.19, 0.29],
    };

    const COLOR_MAP = {
      M50: '#e07b39',
      M57: '#c0392b',
      M65: '#8e44ad',
      M90: '#2980b9',
      WF: '#27ae60',
      WFD: '#16a085',
      Bloc9: '#d35400',
      Bloc14: '#7f8c8d',
      Bloc19: '#2c3e50',
      Bloc29: '#f1c40f',
    };

    const BRICK_TYPES = ['M50', 'M57', 'M65', 'M90', 'WF', 'WFD', 'Bloc9', 'Bloc14', 'Bloc19', 'Bloc29'];
    const SIZE_VARIANTS = ['entire', 'three_quarter', 'half', 'quarter'];

    // State
    let layers = [[/* assise 0 */]];
    let currentLayer = 0;
    let selectedSize = 'M50_entire';
    let hoverPoint = null;
    let jointThickness = 0.01;
    let rotationY = 0;
    let whiteBricks = false;
    let deleteMode = false;
    let projectTitle = '';
    let layerboxPos = { x: window.innerWidth / 2 - 150, y: 160 };
    let titleInputPos = { x: window.innerWidth / 2 - 150, y: 80 };
    let history = [{ layers: JSON.parse(JSON.stringify(layers)), projectTitle: '' }];
    let historyIndex = 0;

    // Three.js Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0.5, 0.5, 1);
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.shadowMap.autoUpdate = false;

    // Gradient Sky
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const context = canvas.getContext('2d');
    const gradient = context.createLinearGradient(0, 0, 0, 512);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(1, '#FFFFFF');
    context.fillStyle = gradient;
    context.fillRect(0, 0, 512, 512);
    const skyTexture = new THREE.CanvasTexture(canvas);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(1, 2, 2);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.left = -2;
    directionalLight.shadow.camera.right = 2;
    directionalLight.shadow.camera.top = 2;
    directionalLight.shadow.camera.bottom = -2;
    directionalLight.shadow.camera.near = 0.1;
    directionalLight.shadow.camera.far = 10;

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = true;
    controls.enableZoom = true;
    controls.enableRotate = true;

    // Ground Plane (Visible Floor)
    const planeGeometry = new THREE.PlaneGeometry(4, 4);
    const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xf0f0f0, visible: true });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;

    // Shadow Plane
    const shadowMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
    const shadowPlane = new THREE.Mesh(planeGeometry, shadowMaterial);
    shadowPlane.rotation.x = -Math.PI / 2;
    shadowPlane.receiveShadow = true;

    // Grid Helper
    const gridHelper = new THREE.GridHelper(4, 400, 0x000000, 0x000000);
    gridHelper.material.opacity = 0.2;
    gridHelper.material.transparent = true;
    gridHelper.visible = false;

    // Raycaster for mouse interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // Initialize Three.js after clicking "Commencer"
    function initThreeJS() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('app').appendChild(renderer.domElement);
      scene.background = skyTexture;
      scene.add(ambientLight, directionalLight, plane, shadowPlane, gridHelper);
    }

    // Create Brick
    function createBrick(position, size, type, transparent = false, highlight = false, rotation = [0, 0, 0], isColliding = false) {
      const geometry = new THREE.BoxGeometry(...size);
      const brickType = type.split('_')[0];
      const color = transparent ? (isColliding ? '#ff0000' : '#00ff00') : (whiteBricks ? '#ffffff' : (highlight ? '#00ffff' : (COLOR_MAP[brickType] || 'orange')));
      const material = new THREE.MeshStandardMaterial({
        color,
        transparent,
        opacity: transparent ? 0.3 : 1,
        wireframe: transparent,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(...position);
      mesh.rotation.set(...rotation);
      mesh.castShadow = !transparent;
      mesh.receiveShadow = true;

      if (!transparent) {
        const edges = new THREE.EdgesGeometry(geometry);
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });
        const edgeLines = new THREE.LineSegments(edges, edgeMaterial);
        edgeLines.position.set(...position);
        edgeLines.rotation.set(...rotation);
        mesh.userData.edges = edgeLines;
      }

      return mesh;
    }

    // Update Scene Bricks
    function updateScene() {
      scene.children = scene.children.filter(child => !child.isMesh && !child.isLineSegments || child === plane || child === shadowPlane || child === gridHelper);
      let hoveredBrick = null;
      if (deleteMode) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children.filter(child => child.isMesh && child !== plane && child !== shadowPlane));
        if (intersects.length > 0) {
          hoveredBrick = intersects[0].object;
        }
      }
      layers.flat().forEach(([x, y, z, type, rotY]) => {
        const isHovered = deleteMode && hoveredBrick && Math.abs(hoveredBrick.position.x - x) < 0.001 && Math.abs(hoveredBrick.position.y - y) < 0.001 && Math.abs(hoveredBrick.position.z - z) < 0.001;
        const brick = createBrick([x, y, z], BRICK_SIZES[type], type, false, isHovered, [0, rotY || 0, 0]);
        scene.add(brick);
        if (brick.userData.edges) scene.add(brick.userData.edges);
      });
      if (hoverPoint && !deleteMode && hoverPoint.x !== undefined && hoverPoint.z !== undefined) {
        let snapX = Math.round(hoverPoint.x * 100) / 100;
        let snapZ = Math.round(hoverPoint.z * 100) / 100;
        const threshold = jointThickness + 0.001;
        const allPositions = layers.flat();
        for (const [x, , z] of allPositions) {
          if (Math.abs(snapX - x) <= threshold) snapX = x;
          if (Math.abs(snapZ - z) <= threshold) snapZ = z;
        }
        const y = getBrickY(BRICK_SIZES[selectedSize]);
        let isColliding = false;
        const newBox = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(snapX, y, snapZ),
          new THREE.Vector3(BRICK_SIZES[selectedSize][0], BRICK_SIZES[selectedSize][1], BRICK_SIZES[selectedSize][2])
        );
        newBox.applyMatrix4(new THREE.Matrix4().makeRotationY(rotationY));
        for (const [x, y2, z, type, rotY] of layers[currentLayer]) {
          if (y !== y2) continue;
          const existingBox = new THREE.Box3().setFromCenterAndSize(
            new THREE.Vector3(x, y2, z),
            new THREE.Vector3(BRICK_SIZES[type][0], BRICK_SIZES[type][1], BRICK_SIZES[type][2])
          );
          existingBox.applyMatrix4(new THREE.Matrix4().makeRotationY(rotY || 0));
          if (newBox.intersectsBox(existingBox)) {
            isColliding = true;
            break;
          }
        }
        const hoverBrick = createBrick([snapX, y, snapZ], BRICK_SIZES[selectedSize], selectedSize, true, false, [0, rotationY, 0], isColliding);
        scene.add(hoverBrick);
      }
      updateBrickCount();
      renderer.shadowMap.needsUpdate = true;
    }

    // Update Brick Count
    function updateBrickCount() {
      const counts = {};
      BRICK_TYPES.forEach(type => {
        counts[type] = {
          entire: layers.flat().filter(b => b[3] === `${type}_entire`).length,
          three_quarter: layers.flat().filter(b => b[3] === `${type}_three_quarter`).length,
          half: layers.flat().filter(b => b[3] === `${type}_half`).length,
          quarter: layers.flat().filter(b => b[3] === `${type}_quarter`).length,
        };
      });

      let html = '';
      BRICK_TYPES.forEach(type => {
        const typeCounts = counts[type];
        const hasNonZero = Object.values(typeCounts).some(count => count > 0);
        if (hasNonZero) {
          html += `<div>${type}:<br>`;
          if (typeCounts.entire > 0) html += `  Enti√®re: ${typeCounts.entire}<br>`;
          if (typeCounts.three_quarter > 0) html += `  Trois quarts: ${typeCounts.three_quarter}<br>`;
          if (typeCounts.half > 0) html += `  Demi: ${typeCounts.half}<br>`;
          if (typeCounts.quarter > 0) html += `  Quart: ${typeCounts.quarter}<br>`;
          html += `</div>`;
        }
      });
      document.getElementById('brick-type-counts').innerHTML = html || 'Aucun √©l√©ment plac√©';
    }

    // Get Brick Y Position
    function getBrickY(size) {
      return size[1] / 2 + jointThickness + currentLayer * (size[1] + jointThickness);
    }

    // Save History State
    function saveState() {
      history = history.slice(0, historyIndex + 1);
      history.push({ layers: JSON.parse(JSON.stringify(layers)), projectTitle });
      historyIndex++;
    }

    // Add Brick with Collision Detection
    function addBrick(point) {
      if (!point || point.x === undefined || point.z === undefined) return;
      const allPositions = layers.flat();
      const threshold = jointThickness + 0.001;
      const size = BRICK_SIZES[selectedSize];
      let snapX = Math.round(point.x * 100) / 100;
      let snapZ = Math.round(point.z * 100) / 100;
      let snappedX = snapX;
      let snappedZ = snapZ;

      for (const [x, , z] of allPositions) {
        if (Math.abs(snappedX - x) <= threshold) snappedX = x;
        if (Math.abs(snappedZ - z) <= threshold) snappedZ = z;
      }

      const y = getBrickY(size);
      const newBox = new THREE.Box3().setFromCenterAndSize(
        new THREE.Vector3(snappedX, y, snappedZ),
        new THREE.Vector3(size[0], size[1], size[2])
      );
      const rotationMatrix = new THREE.Matrix4().makeRotationY(rotationY);
      newBox.applyMatrix4(rotationMatrix);

      for (const [x, y2, z, type, rotY] of layers[currentLayer]) {
        if (y !== y2) continue;
        const existingBox = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(x, y2, z),
          new THREE.Vector3(BRICK_SIZES[type][0], BRICK_SIZES[type][1], BRICK_SIZES[type][2])
        );
        const existingRotation = new THREE.Matrix4().makeRotationY(rotY || 0);
        existingBox.applyMatrix4(existingRotation);
        if (newBox.intersectsBox(existingBox)) {
          const notification = document.getElementById('notification');
          notification.textContent = 'Erreur : Chevauchement d√©tect√©';
          notification.style.left = `${Math.min(window.innerWidth - 200, Math.max(0, mouse.x * window.innerWidth / 2 + window.innerWidth / 2 + 10))}px`;
          notification.style.top = `${-mouse.y * window.innerHeight / 2 + window.innerHeight / 2 + 10}px`;
          notification.style.display = 'block';
          setTimeout(() => notification.style.display = 'none', 2000);
          return;
        }
      }

      saveState();
      layers[currentLayer].push([snappedX, y, snappedZ, selectedSize, rotationY]);
      updateScene();
    }

    // Delete Brick
    function deleteBrick() {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children.filter(child => child.isMesh && child !== plane && child !== shadowPlane));
      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const position = clickedMesh.position;
        saveState();
        for (let i = 0; i < layers.length; i++) {
          layers[i] = layers[i].filter(([x, y, z]) => {
            return !(Math.abs(x - position.x) < 0.001 && Math.abs(y - position.y) < 0.001 && Math.abs(z - position.z) < 0.001);
          });
        }
        deleteMode = false;
        document.getElementById('delete-mode').classList.remove('delete-active');
        updateScene();
      }
    }

    // Add Layer
    function addLayer() {
      saveState();
      layers.push([]);
      currentLayer = layers.length - 1;
      updateLayerSelect();
      updateScene();
    }

    // Undo
    function undo() {
      if (historyIndex <= 0) return;
      historyIndex--;
      layers = JSON.parse(JSON.stringify(history[historyIndex].layers));
      projectTitle = history[historyIndex].projectTitle;
      document.getElementById('project-title').value = projectTitle;
      updateLayerSelect();
      updateScene();
    }

    // Redo
    function redo() {
      if (historyIndex >= history.length - 1) return;
      historyIndex++;
      layers = JSON.parse(JSON.stringify(history[historyIndex].layers));
      projectTitle = history[historyIndex].projectTitle;
      document.getElementById('project-title').value = projectTitle;
      updateLayerSelect();
      updateScene();
    }

    // Export PDF
    function exportPDF() {
      const originalWidth = window.innerWidth;
      const originalHeight = window.innerHeight;
      const exportWidth = 1920;
      const exportHeight = exportWidth * (originalHeight / originalWidth);

      const pdf = new jsPDF({ orientation: 'landscape', unit: 'cm', format: [21, 29.7] });
      const width = pdf.internal.pageSize.getWidth();
      const height = pdf.internal.pageSize.getHeight();

      renderer.setSize(exportWidth, exportHeight);
      renderer.setClearColor(0xffffff, 1);

      // Page 1: Top view
      let minX = 0, maxX = 0, minZ = 0, maxZ = 0;
      layers.flat().forEach(([x, , z]) => {
        minX = Math.min(minX, x - 0.39 / 2);
        maxX = Math.max(maxX, x + 0.39 / 2);
        minZ = Math.min(minZ, z - 0.39 / 2);
        maxZ = Math.max(maxZ, z + 0.39 / 2);
      });
      const padding = 0.1;
      const topWidth = Math.max(2, maxX - minX + padding);
      const topHeight = Math.max(2, maxZ - minZ + padding);
      renderer.shadowMap.enabled = false;
      scene.background = null;
      const topCamera = new THREE.OrthographicCamera(-topWidth / 2, topWidth / 2, topHeight / 2, -topHeight / 2, 0.1, 100);
      topCamera.position.set(0, 1, 0);
      topCamera.lookAt(0, 0, 0);
      renderer.render(scene, topCamera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 0, 0, width, height);
      pdf.setLineWidth(0.05);
      pdf.line(1, height - 2, 1 + 1, height - 2);
      pdf.setFontSize(8);
      pdf.text('100 cm', 1, height - 1.5);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Vue de dessus', width / 2, height - 1, { align: 'center' });
      if (projectTitle) {
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        pdf.text(projectTitle, width / 2, height - 1.5, { align: 'center' });
      }
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.text('Wall Simulateur 3d', width - 3, height - 1.5, { align: 'right' });
      pdf.text('Made by Julien BROHEZ', width - 3, height - 1, { align: 'right' });

      // Page 2: Front view
      pdf.addPage();
      const frontLineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-2, 0, 0),
        new THREE.Vector3(2, 0, 0)
      ]);
      const frontLineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 5 });
      const frontLine = new THREE.Line(frontLineGeometry, frontLineMaterial);
      scene.add(frontLine);
      scene.background = null;
      const frontCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 100);
      frontCamera.position.set(0, 0.5, 1);
      frontCamera.lookAt(0, 0.5, 0);
      renderer.render(scene, frontCamera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 0, 0, width, height);
      pdf.setLineWidth(0.05);
      pdf.line(1, height - 2, 1 + 1, height - 2);
      pdf.setFontSize(8);
      pdf.text('100 cm', 1, height - 1.5);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Vue de face', width / 2, height - 1, { align: 'center' });
      if (projectTitle) {
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        pdf.text(projectTitle, width / 2, height - 1.5, { align: 'center' });
      }
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.text('Wall Simulateur 3d', width - 3, height - 1.5, { align: 'right' });
      pdf.text('Made by Julien BROHEZ', width - 3, height - 1, { align: 'right' });
      scene.remove(frontLine);

      // Page 3: Side view
      pdf.addPage();
      const sideLineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, -2),
        new THREE.Vector3(0, 0, 2)
      ]);
      const sideLineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 5 });
      const sideLine = new THREE.Line(sideLineGeometry, sideLineMaterial);
      scene.add(sideLine);
      scene.background = null;
      const sideCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 100);
      sideCamera.position.set(1, 0.5, 0);
      sideCamera.lookAt(0, 0.5, 0);
      renderer.render(scene, sideCamera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 0, 0, width, height);
      pdf.setLineWidth(0.05);
      pdf.line(1, height - 2, 1 + 1, height - 2);
      pdf.setFontSize(8);
      pdf.text('100 cm', 1, height - 1.5);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Vue de c√¥t√©', width / 2, height - 1, { align: 'center' });
      if (projectTitle) {
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        pdf.text(projectTitle, width / 2, height - 1.5, { align: 'center' });
      }
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.text('Wall Simulateur 3d', width - 3, height - 1.5, { align: 'right' });
      pdf.text('Made by Julien BROHEZ', width - 3, height - 1, { align: 'right' });
      scene.remove(sideLine);

      // Page 4: 3D view
      pdf.addPage();
      renderer.shadowMap.enabled = true;
      scene.background = skyTexture;
      camera.aspect = exportWidth / exportHeight;
      camera.updateProjectionMatrix();
      camera.lookAt(controls.target);
      renderer.render(scene, camera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 0, 0, width, height);
      pdf.setLineWidth(0.05);
      pdf.line(1, height - 2, 1 + 1, height - 2);
      pdf.setFontSize(8);
      pdf.text('100 cm', 1, height - 1.5);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Vue 3D', width / 2, height - 1, { align: 'center' });
      if (projectTitle) {
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        pdf.text(projectTitle, width / 2, height - 1.5, { align: 'center' });
      }
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.text('Wall Simulateur 3d', width - 3, height - 1.5, { align: 'right' });
      pdf.text('Made by Julien BROHEZ', width - 3, height - 1, { align: 'right' });

      // Page 5: Element inventory
      pdf.addPage();
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Inventaire des √©l√©ments', width / 2, 1, { align: 'center' });
      if (projectTitle) {
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        pdf.text(projectTitle, width / 2, 1.5, { align: 'center' });
      }
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(10);
      let y = projectTitle ? 2.5 : 2;
      BRICK_TYPES.forEach(type => {
        SIZE_VARIANTS.forEach(variant => {
          const count = layers.flat().filter(b => b[3] === `${type}_${variant}`).length;
          if (count > 0) {
            pdf.text(`${type} (${variant}): ${count} √©l√©ments`, 1, y);
            y += 1;
          }
        });
      });

      renderer.setSize(originalWidth, originalHeight);
      camera.aspect = originalWidth / originalHeight;
      camera.updateProjectionMatrix();
      renderer.shadowMap.enabled = true;
      scene.background = skyTexture;
      renderer.setClearColor(0x000000, 0);

      pdf.save('vue-elements.pdf');
    }

    // Export PNG
    function exportPNG() {
      if (projectTitle) {
        const canvas = document.createElement('canvas');
        canvas.width = renderer.domElement.width;
        canvas.height = renderer.domElement.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(renderer.domElement, 0, 0);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, 50);
        ctx.fillStyle = '#000000';
        ctx.font = 'bold 30px Helvetica';
        ctx.textAlign = 'center';
        ctx.fillText(projectTitle, canvas.width / 2, 40);
        const link = document.createElement('a');
        link.download = 'vue-elements.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      } else {
        renderer.render(scene, camera);
        const link = document.createElement('a');
        link.download = 'vue-elements.png';
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();
      }
    }

    // Update Layer Select
    function updateLayerSelect() {
      const select = document.getElementById('layer-select');
      select.innerHTML = '';
      layers.forEach((_, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Assise ${i + 1}`;
        if (i === currentLayer) option.selected = true;
        select.appendChild(option);
      });
    }

    // Drag Handling
    function makeDraggable(element, pos) {
      let isDragging = false;
      let startX, startY;

      element.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'LABEL' || e.target.tagName === 'INPUT') return;
        isDragging = true;
        startX = e.clientX - pos.x;
        startY = e.clientY - pos.y;
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        let x = e.clientX - startX;
        let y = e.clientY - startY;

        if (element.id === 'layerbox') {
          y = Math.max(160, Math.min(y, 210));
          x = Math.max(0, Math.min(x, window.innerWidth - element.offsetWidth));
        } else if (element.id === 'title-input') {
          y = Math.max(80, Math.min(y, 130));
          x = Math.max(0, Math.min(x, window.innerWidth - element.offsetWidth));
        }

        pos.x = x;
        pos.y = y;
        element.style.left = `${x}px`;
        element.style.top = `${y}px`;
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    }

    // Save File
    function saveFile() {
      const data = JSON.stringify({ layers, projectTitle });
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'wall-design.json';
      link.click();
      URL.revokeObjectURL(url);
    }

    // Open File
    function openFile() {
      document.getElementById('file-input').click();
    }

    function validateLayers(data) {
      if (!data || typeof data !== 'object') return false;
      const { layers, projectTitle } = data;
      return (
        Array.isArray(layers) &&
        layers.every(layer => Array.isArray(layer) && layer.every(([x, y, z, type, rotY]) => 
          typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && 
          BRICK_SIZES[type] && (rotY === undefined || typeof rotY === 'number')
        )) &&
        (typeof projectTitle === 'string' || projectTitle === undefined)
      );
    }

    // Event Listeners
    function setupEventListeners() {
      document.getElementById('project-title').addEventListener('input', (e) => {
        projectTitle = e.target.value.slice(0, 100);
        saveState();
      });
      document.getElementById('brick-type').addEventListener('change', (e) => {
        const brickType = e.target.value;
        const sizeVariant = document.getElementById('brick-size').value;
        selectedSize = `${brickType}_${sizeVariant}`;
        updateScene();
      });
      document.getElementById('brick-size').addEventListener('change', (e) => {
        const sizeVariant = e.target.value;
        const brickType = document.getElementById('brick-type').value;
        selectedSize = `${brickType}_${sizeVariant}`;
        updateScene();
      });
      document.getElementById('rotation-y').addEventListener('input', (e) => {
        rotationY = (e.target.value * Math.PI) / 180;
        document.getElementById('rotation-value').textContent = `${e.target.value}¬∞`;
        updateScene();
      });
      document.getElementById('joint-thickness').addEventListener('input', (e) => {
        jointThickness = parseFloat(e.target.value) / 100;
        updateScene();
      });
      document.getElementById('white-bricks').addEventListener('change', (e) => {
        whiteBricks = e.target.checked;
        updateScene();
      });
      document.getElementById('show-grid').addEventListener('change', (e) => {
        gridHelper.visible = e.target.checked;
        renderer.render(scene, camera);
      });
      document.getElementById('layer-select').addEventListener('change', (e) => {
        currentLayer = parseInt(e.target.value);
        updateScene();
      });
      document.getElementById('add-layer').addEventListener('click', addLayer);
      document.getElementById('undo').addEventListener('click', undo);
      document.getElementById('redo').addEventListener('click', redo);
      document.getElementById('delete-mode').addEventListener('click', () => {
        deleteMode = !deleteMode;
        document.getElementById('delete-mode').classList.toggle('delete-active', deleteMode);
        updateScene();
      });
      document.getElementById('save-file').addEventListener('click', saveFile);
      document.getElementById('open-file').addEventListener('click', openFile);
      document.getElementById('file-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);
            if (validateLayers(data)) {
              layers = data.layers;
              projectTitle = data.projectTitle || '';
              document.getElementById('project-title').value = projectTitle;
              currentLayer = Math.min(currentLayer, layers.length - 1);
              history = [{ layers: JSON.parse(JSON.stringify(layers)), projectTitle }];
              historyIndex = 0;
              updateLayerSelect();
              updateScene();
            } else {
              const notification = document.getElementById('notification');
              notification.textContent = 'Erreur : Format de fichier invalide';
              notification.style.left = `${window.innerWidth / 2}px`;
              notification.style.top = `${window.innerHeight / 2}px`;
              notification.style.display = 'block';
              setTimeout(() => notification.style.display = 'none', 2000);
            }
          } catch (err) {
            const notification = document.getElementById('notification');
            notification.textContent = `Erreur : ${err.message}`;
            notification.style.left = `${window.innerWidth / 2}px`;
            notification.style.top = `${window.innerHeight / 2}px`;
            notification.style.display = 'block';
            setTimeout(() => notification.style.display = 'none', 2000);
          }
        };
        reader.readAsText(file);
        e.target.value = '';
      });
      document.getElementById('export-pdf').addEventListener('click', exportPDF);
      document.getElementById('export-png').addEventListener('click', exportPNG);

      document.addEventListener('mousemove', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(plane);
        if (intersects.length > 0 && !deleteMode) {
          hoverPoint = intersects[0].point;
        } else {
          hoverPoint = null;
        }
        updateScene();
      });

      document.addEventListener('click', (e) => {
        if (deleteMode) {
          deleteBrick();
        }
      });

      document.addEventListener('dblclick', (e) => {
        if (!deleteMode) {
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(plane);
          if (intersects.length > 0) {
            addBrick(intersects[0].point);
          }
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        layerboxPos.x = window.innerWidth / 2 - document.getElementById('layerbox').offsetWidth / 2;
        titleInputPos.x = window.innerWidth / 2 - document.getElementById('title-input').offsetWidth / 2;
        document.getElementById('layerbox').style.left = `${layerboxPos.x}px`;
        document.getElementById('title-input').style.left = `${titleInputPos.x}px`;
      });

      makeDraggable(document.getElementById('layerbox'), layerboxPos);
      makeDraggable(document.getElementById('title-input'), titleInputPos);
    }

    // Homepage Button
    document.getElementById('start-button').addEventListener('click', () => {
      document.getElementById('homepage').style.display = 'none';
      document.getElementById('app').style.display = 'block';
      initThreeJS();
      setupEventListeners();
      updateLayerSelect();
      animate();
    });

    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
