<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mur Simulateur 3d</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #ffffff; color: #000000; font-family: Arial, sans-serif; }
    canvas { width: 100%; height: 100vh; }
    .toolbox, .layerbox, .brick-counter, .version, .title-input { position: absolute; background: #e2e8f0; padding: 8px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); z-index: 10; }
    .toolbox { top: 50px; left: 60px; width: 256px; }
    .layerbox { top: 360px; left: 60px; cursor: move; width: auto; max-width: 600px; display: flex; flex-direction: column; align-items: center; gap: 8px; pointer-events: none; }
    .layerbox * { pointer-events: auto; }
    .brick-counter { bottom: 50px; right: 10px; width: 300px; }
    .title-input { top: 50px; left: 50%; transform: translateX(-50%); width: 300px; cursor: move; pointer-events: none; }
    .title-input * { pointer-events: auto; }
    .version { bottom: 50px; left: 60px; font-size: 12px; padding: 8px; }
    button { padding: 4px; border-radius: 4px; border: none; cursor: pointer; font-size: 12px; font-weight: bold; color: #000000; }
    button:hover { opacity: 0.8; }
    .delete-active, .move-active, .rotate-active { background-color: #b7791f !important; }
    input, select { background: #edf2f7; color: #000000; border: none; padding: 4px; border-radius: 4px; width: 100%; }
    label { font-size: 14px; margin-bottom: 4px; display: block; }
    h2 { font-size: 18px; margin-bottom: 8px; color: #000000; }
    .brick-type-count { font-size: 14px; }
    #homepage { display: flex; }
    #app { display: none; }
    #notification { display: none; }
    .menu-bar { position: fixed; top: 0; left: 0; width: 100%; background: #f1f1f1; border-bottom: 1px solid #d1d5db; display: flex; align-items: center; justify-content: space-between; z-index: 20; padding: 0 16px; }
    .menu-bar ul { list-style: none; margin: 0; padding: 0; display: flex; }
    .menu-bar li { position: relative; }
    .menu-bar li a { display: block; padding: 8px 16px; color: #000000; text-decoration: none; font-size: 14px; }
    .menu-bar li:hover { background: #e5e7eb; }
    .menu-bar .dropdown { display: none; position: absolute; top: 100%; left: 0; background: #ffffff; border: 1px solid #d1d5db; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
    .menu-bar li:hover .dropdown { display: block; }
    .menu-bar .dropdown a { padding: 8px 16px; display: block; color: #000000; }
    .menu-bar .dropdown a:hover { background: #f1f1f1; }
    .menu-bar .title { font-size: 24px; font-weight: bold; color: #000000; }
    .left-toolbar { position: fixed; top: 40px; left: 0; width: 50px; background: #e2e8f0; height: calc(100vh - 80px); display: flex; flex-direction: column; align-items: center; padding: 8px 0; box-shadow: 2px 0 4px rgba(0, 0, 0, 0.1); }
    .left-toolbar button { margin: 4px 0; width: 40px; height: 40px; background: #edf2f7; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 20px; }
    .left-toolbar button:hover { background: #d1d5db; }
    .instruction-bar { position: fixed; bottom: 0; left: 0; width: 100%; background: #f1f1f1; border-top: 1px solid #d1d5db; padding: 8px; text-align: center; font-size: 14px; color: #000000; z-index: 20; }
    .rotate-overlay { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #e2e8f0; padding: 16px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); z-index: 30; }
    .rotate-overlay label { margin-bottom: 8px; }
    .rotate-overlay input[type="range"] { width: 200px; }
    .rotate-overlay button { margin-top: 8px; width: 100%; background: #3182ce; color: #ffffff; }
    .brick-type-count table { width: 100%; }
  </style>
</head>
<body>
  <div id="notification" class="absolute bg-red-600 text-white px-4 py-2 rounded-lg" style="display: none; z-index: 20;"></div>
  <div id="homepage" class="flex flex-col items-center justify-center h-screen">
    <img src="https://julienbro.github.io/simulateur-briques/logo.png" alt="Mur Simulateur 3d Logo" class="mb-4">
    <p class="text-lg text-black mt-2">Con√ßu par Julien BROHEZ</p>
    <p class="text-lg text-black mt-2">Version 1.0.0</p>
    <button id="start-button" class="mt-6 bg-green-600 text-white px-6 py-3 text-lg rounded-lg hover:bg-green-700 transition">Commencer</button>
  </div>
  <div id="app">
    <div class="menu-bar">
      <ul>
        <li>
          <a href="#">Fichier</a>
          <div class="dropdown">
            <a href="#" id="save-file">Enregistrer</a>
            <a href="#" id="open-file">Ouvrir</a>
            <a href="#" id="export-pdf">Exporter PDF</a>
            <a href="#" id="export-png">Exporter PNG</a>
          </div>
        </li>
        <li>
          <a href="#">Vue</a>
          <div class="dropdown">
            <a href="#" id="toggle-white-bricks">Afficher/Cacher en blanc</a>
            <a href="#" id="toggle-grid">Afficher/Cacher Grille</a>
            <a href="#" id="reset-camera">R√©initialiser Cam√©ra</a>
          </div>
        </li>
        <li>
          <a href="#">Assises</a>
          <div class="dropdown">
            <a href="#" id="add-layer">Ajouter Assise</a>
          </div>
        </li>
        <li>
          <a href="#">Aide</a>
          <div class="dropdown">
            <a href="#">√Ä propos</a>
          </div>
        </li>
      </ul>
      <div class="title">Mur Simulateur 3d</div>
    </div>
    <div class="left-toolbar">
      <button title="S√©lectionner">üñ±Ô∏è</button>
      <button title="Placer Brique">üß±</button>
      <button title="Effacer" id="delete-mode">üóëÔ∏è</button>
      <button title="D√©placer" id="move-mode">‚ÜîÔ∏è</button>
      <button title="Tourner" id="rotate-mode">üîÑ</button>
      <button title="Annuler" id="undo">‚Ü©Ô∏è</button>
      <button title="Refaire" id="redo">‚Ü™Ô∏è</button>
    </div>
    <div id="rotate-overlay" class="rotate-overlay">
      <label>Rotation Y (¬∞)</label>
      <input type="range" id="rotate-slider" min="0" max="355" step="15" value="0">
      <div id="rotate-value" style="text-align: center; font-size: 12px; margin-top: 4px;">0¬∞</div>
      <button id="confirm-rotation">Confirmer</button>
    </div>
    <div id="instruction-bar" class="instruction-bar">
      Double-cliquez pour placer une brique
    </div>
    <div id="title-input" class="title-input">
      <label for="project-title">Titre du projet</label>
      <input type="text" id="project-title" maxlength="100" placeholder="Entrez le titre du projet">
    </div>
    <div id="toolbox" class="toolbox">
      <h2>üß± Outils de pose</h2>
      <label for="brick-type">Type de brique/bloc</label>
      <select id="brick-type">
        <option value="M50">Brique M50</option>
        <option value="M57">Brique M57</option>
        <option value="M65">Brique M65</option>
        <option value="M90">Brique M90</option>
        <option value="WF">Brique WF</option>
        <option value="WFD">Brique WFD</option>
        <option value="Bloc9">Bloc de 9</option>
        <option value="Bloc14">Bloc de 14</option>
        <option value="Bloc19">Bloc de 19</option>
        <option value="Bloc29">Bloc de 29</option>
      </select>
      <label for="brick-size">Taille</label>
      <select id="brick-size">
        <option value="entire">Enti√®re</option>
        <option value="three_quarter">Trois quarts</option>
        <option value="half">Demi</option>
        <option value="quarter">Quart</option>
      </select>
      <label>Rotation Y (¬∞)</label>
      <input type="range" id="rotation-y" min="0" max="355" step="15" value="0">
      <div id="rotation-value" style="text-align: center; font-size: 12px;">0¬∞</div>
      <label>√âpaisseur du joint (cm)</label>
      <input type="number" id="joint-thickness" min="0" step="0.1" value="1.2">
    </div>
    <div id="layerbox" class="layerbox">
      <div style="display: flex; align-items: center; gap: 12px;">
        <label>Assise active</label>
        <select id="layer-select"></select>
      </div>
    </div>
    <div id="brick-counter" class="brick-counter">
      <h2>üßÆ Compteur d'√©l√©ments</h2>
      <div id="brick-type-counts" class="brick-type-count"></div>
    </div>
    <div id="version" class="version">Version 1.0.0</div>
    <input type="file" id="file-input" accept=".json" style="display: none;">
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    const { jsPDF } = window.jspdf;

    const BRICK_SIZES = {
      M50_entire: [0.19, 0.05, 0.09],
      M50_three_quarter: [0.14, 0.05, 0.09],
      M50_half: [0.09, 0.05, 0.09],
      M50_quarter: [0.04, 0.05, 0.09],
      M57_entire: [0.19, 0.057, 0.09],
      M57_three_quarter: [0.14, 0.057, 0.09],
      M57_half: [0.09, 0.057, 0.09],
      M57_quarter: [0.04, 0.057, 0.09],
      M65_entire: [0.19, 0.065, 0.09],
      M65_three_quarter: [0.14, 0.065, 0.09],
      M65_half: [0.09, 0.065, 0.09],
      M65_quarter: [0.04, 0.065, 0.09],
      M90_entire: [0.19, 0.09, 0.09],
      M90_three_quarter: [0.14, 0.09, 0.09],
      M90_half: [0.09, 0.09, 0.09],
      M90_quarter: [0.04, 0.09, 0.09],
      WF_entire: [0.21, 0.09, 0.09],
      WF_three_quarter: [0.15, 0.05, 0.09],
      WF_half: [0.10, 0.05, 0.09],
      WF_quarter: [0.05, 0.05, 0.09],
      WFD_entire: [0.21, 0.09, 0.09],
      WFD_three_quarter: [0.15, 0.05, 0.09],
      WFD_half: [0.10, 0.05, 0.09],
      WFD_quarter: [0.05, 0.05, 0.09],
      Bloc9_entire: [0.39, 0.19, 0.09],
      Bloc9_three_quarter: [0.29, 0.19, 0.09],
      Bloc9_half: [0.19, 0.19, 0.09],
      Bloc9_quarter: [0.14, 0.19, 0.09],
      Bloc14_entire: [0.39, 0.19, 0.14],
      Bloc14_three_quarter: [0.29, 0.19, 0.14],
      Bloc14_half: [0.19, 0.19, 0.14],
      Bloc14_quarter: [0.14, 0.19, 0.14],
      Bloc19_entire: [0.39, 0.19, 0.19],
      Bloc19_three_quarter: [0.29, 0.19, 0.19],
      Bloc19_half: [0.19, 0.19, 0.19],
      Bloc19_quarter: [0.14, 0.19, 0.19],
      Bloc29_entire: [0.39, 0.19, 0.29],
      Bloc29_three_quarter: [0.29, 0.19, 0.29],
      Bloc29_half: [0.19, 0.19, 0.29],
      Bloc29_quarter: [0.14, 0.19, 0.29],
    };

    const COLOR_MAP = {
      M50: '#e07b39',
      M57: '#c0392b',
      M65: '#8e44ad',
      M90: '#2980b9',
      WF: '#27ae60',
      WFD: '#16a085',
      Bloc9: '#d35400',
      Bloc14: '#7f8c8d',
      Bloc19: '#2c3e50',
      Bloc29: '#f1c40f',
    };

    const SIZE_COLOR_MAP = {
      entire: '#ff0000',
      three_quarter: '#00ff00',
      half: '#0000ff',
      quarter: '#ffff00'
    };

    const BRICK_TYPES = ['M50', 'M57', 'M65', 'M90', 'WF', 'WFD', 'Bloc9', 'Bloc14', 'Bloc19', 'Bloc29'];
    const SIZE_VARIANTS = ['entire', 'three_quarter', 'half', 'quarter'];

    let layers = [[/* assise 0 */]];
    let currentLayer = 0;
    let selectedSize = 'M50_entire';
    let hoverPoint = null;
    let jointThickness = 0.012;
    let rotationY = 0;
    let whiteBricks = false;
    let deleteMode = false;
    let moveMode = false;
    let rotateMode = false;
    let projectTitle = '';
    let layerboxPos = { x: 60, y: 360 };
    let titleInputPos = { x: window.innerWidth / 2 - 150, y: 50 };
    let history = [{ layers: JSON.parse(JSON.stringify(layers)), projectTitle: '' }];
    let historyIndex = 0;
    let selectedBrick = null;
    let ghostBrick = null;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0.5, 0.5, 1);
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.shadowMap.autoUpdate = false;

    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const context = canvas.getContext('2d');
    const gradient = context.createLinearGradient(0, 0, 0, 512);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(1, '#FFFFFF');
    context.fillStyle = gradient;
    context.fillRect(0, 0, 512, 512);
    const skyTexture = new THREE.CanvasTexture(canvas);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(1, 2, 2);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.left = -2;
    directionalLight.shadow.camera.right = 2;
    directionalLight.shadow.camera.top = 2;
    directionalLight.shadow.camera.bottom = -2;
    directionalLight.shadow.camera.near = 0.1;
    directionalLight.shadow.camera.far = 10;

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = true;
    controls.enableZoom = true;
    controls.enableRotate = true;

    const planeGeometry = new THREE.PlaneGeometry(4, 4);
    const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xf0f0f0, visible: true });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;

    const shadowMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
    const shadowPlane = new THREE.Mesh(planeGeometry, shadowMaterial);
    shadowPlane.rotation.x = -Math.PI / 2;
    shadowPlane.receiveShadow = true;

    const gridHelper = new THREE.GridHelper(4, 400, 0x000000, 0x000000);
    gridHelper.material.opacity = 0.2;
    gridHelper.material.transparent = true;
    gridHelper.visible = false;

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function initThreeJS() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('app').appendChild(renderer.domElement);
      scene.background = skyTexture;
      scene.add(ambientLight, directionalLight, plane, shadowPlane, gridHelper);
    }

    function createBrick(position, size, type, transparent = false, highlight = false, rotation = [0, 0, 0], isColliding = false, isJointAligned = false) {
      const geometry = new THREE.BoxGeometry(...size);
      const brickType = type.split('_')[0];
      const brickSize = type.split('_')[1];
      const color = transparent 
        ? (isColliding ? '#ff0000' : (isJointAligned ? '#0000ff' : '#00ff00')) 
        : (whiteBricks ? '#ffffff' : (highlight ? '#00ffff' : (SIZE_COLOR_MAP[brickSize] || COLOR_MAP[brickType] || 'orange')));
      const material = new THREE.MeshStandardMaterial({
        color,
        transparent,
        opacity: transparent ? 0.3 : 1,
        wireframe: transparent,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(...position);
      mesh.rotation.set(...rotation);
      mesh.castShadow = !transparent;
      mesh.receiveShadow = true;
      mesh.userData.type = type;

      if (!transparent) {
        const edges = new THREE.EdgesGeometry(geometry);
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });
        const edgeLines = new THREE.LineSegments(edges, edgeMaterial);
        edgeLines.position.set(...position);
        edgeLines.rotation.set(...rotation);
        mesh.userData.edges = edgeLines;
      }

      return mesh;
    }

    function updateScene() {
      scene.children = scene.children.filter(child => !child.isMesh && !child.isLineSegments || child === plane || child === shadowPlane || child === gridHelper);
      let hoveredBrick = null;
      if (deleteMode || moveMode || rotateMode) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children.filter(child => child.isMesh && child !== plane && child !== shadowPlane));
        if (intersects.length > 0) {
          hoveredBrick = intersects[0].object;
        }
      }
      layers.flat().forEach(([x, y, z, type, rotY], index) => {
        const isHovered = (deleteMode || moveMode || rotateMode) && hoveredBrick && Math.abs(hoveredBrick.position.x - x) < 0.001 && Math.abs(hoveredBrick.position.y - y) < 0.001 && Math.abs(hoveredBrick.position.z - z) < 0.001;
        const brick = createBrick([x, y, z], BRICK_SIZES[type], type, false, isHovered, [0, rotY || 0, 0]);
        brick.userData.index = index;
        brick.userData.layerIndex = layers.findIndex(layer => layer.some(b => b[0] === x && b[1] === y && b[2] === z));
        scene.add(brick);
        if (brick.userData.edges) scene.add(brick.userData.edges);
      });
      if (hoverPoint && !deleteMode && !moveMode && !rotateMode && hoverPoint.x !== undefined && hoverPoint.z !== undefined) {
        let snapX = Math.round(hoverPoint.x * 100) / 100;
        let snapZ = Math.round(hoverPoint.z * 100) / 100;
        const threshold = jointThickness + 0.001;
        const allPositions = layers.flat();
        for (const [x, , z] of allPositions) {
          if (Math.abs(snapX - x) <= threshold) snapX = x;
          if (Math.abs(snapZ - z) <= threshold) snapZ = z;
        }
        const y = getBrickY(BRICK_SIZES[selectedSize]);
        let isColliding = false;
        const newBox = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(snapX, y, snapZ),
          new THREE.Vector3(BRICK_SIZES[selectedSize][0], BRICK_SIZES[selectedSize][1], BRICK_SIZES[selectedSize][2])
        );
        newBox.applyMatrix4(new THREE.Matrix4().makeRotationY(rotationY));
        for (const [x, y2, z, type, rotY] of layers[currentLayer]) {
          if (y !== y2) continue;
          const existingBox = new THREE.Box3().setFromCenterAndSize(
            new THREE.Vector3(x, y2, z),
            new THREE.Vector3(BRICK_SIZES[type][0], BRICK_SIZES[type][1], BRICK_SIZES[type][2])
          );
          existingBox.applyMatrix4(new THREE.Matrix4().makeRotationY(rotY || 0));
          if (newBox.intersectsBox(existingBox)) {
            isColliding = true;
            break;
          }
        }
        const isJointAligned = layers[currentLayer].some(([x, y2, z]) => {
          if (y !== y2) return false;
          const dx = Math.abs(snapX - x);
          const dz = Math.abs(snapZ - z);
          return (
            (Math.abs(dx - jointThickness) < 0.001 && dz < 0.001) ||
            (Math.abs(dz - jointThickness) < 0.001 && dx < 0.001)
          );
        });
        const hoverBrick = createBrick([snapX, y, snapZ], BRICK_SIZES[selectedSize], selectedSize, true, false, [0, rotationY, 0], isColliding, isJointAligned);
        scene.add(hoverBrick);
      }
      if (moveMode && selectedBrick && hoverPoint) {
        let snapX = Math.round(hoverPoint.x * 100) / 100;
        let snapZ = Math.round(hoverPoint.z * 100) / 100;
        const threshold = jointThickness + 0.001;
        const allPositions = layers.flat().filter(([x, y, z]) => !(Math.abs(x - selectedBrick[0]) < 0.001 && Math.abs(y - selectedBrick[1]) < 0.001 && Math.abs(z - selectedBrick[2]) < 0.001));
        for (const [x, , z] of allPositions) {
          if (Math.abs(snapX - x) <= threshold) snapX = x;
          if (Math.abs(snapZ - z) <= threshold) snapZ = z;
        }
        const y = selectedBrick[1];
        let isColliding = false;
        const newBox = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(snapX, y, snapZ),
          new THREE.Vector3(BRICK_SIZES[selectedBrick[3]][0], BRICK_SIZES[selectedBrick[3]][1], BRICK_SIZES[selectedBrick[3]][2])
        );
        newBox.applyMatrix4(new THREE.Matrix4().makeRotationY(selectedBrick[4] || 0));
        for (const [x, y2, z, type, rotY] of layers[currentLayer]) {
          if (y !== y2) continue;
          const existingBox = new THREE.Box3().setFromCenterAndSize(
            new THREE.Vector3(x, y2, z),
            new THREE.Vector3(BRICK_SIZES[type][0], BRICK_SIZES[type][1], BRICK_SIZES[type][2])
          );
          existingBox.applyMatrix4(new THREE.Matrix4().makeRotationY(rotY || 0));
          if (newBox.intersectsBox(existingBox)) {
            isColliding = true;
            break;
          }
        }
        const isJointAligned = layers[currentLayer].some(([x, y2, z]) => {
          if (y !== y2) return false;
          const dx = Math.abs(snapX - x);
          const dz = Math.abs(snapZ - z);
          return (
            (Math.abs(dx - jointThickness) < 0.001 && dz < 0.001) ||
            (Math.abs(dz - jointThickness) < 0.001 && dx < 0.001)
          );
        });
        ghostBrick = createBrick([snapX, y, snapZ], BRICK_SIZES[selectedBrick[3]], selectedBrick[3], true, false, [0, selectedBrick[4] || 0, 0], isColliding, isJointAligned);
        scene.add(ghostBrick);
      }
      updateBrickCount();
      renderer.shadowMap.needsUpdate = true;
      updateInstructions();
    }

    function updateInstructions() {
      const instructionBar = document.getElementById('instruction-bar');
      if (deleteMode) {
        instructionBar.textContent = 'Cliquez sur une brique pour la supprimer';
      } else if (moveMode) {
        instructionBar.textContent = selectedBrick ? 'D√©placez la brique et cliquez pour confirmer la position' : 'S√©lectionnez une brique √† d√©placer';
      } else if (rotateMode) {
        instructionBar.textContent = selectedBrick ? 'Ajustez la rotation et confirmez' : 'S√©lectionnez une brique √† tourner';
      } else {
        instructionBar.textContent = 'Double-cliquez pour placer une brique';
      }
    }

    function updateBrickCount() {
      const counts = {};
      BRICK_TYPES.forEach(type => {
        counts[type] = {
          entire: layers.flat().filter(b => b[3] === `${type}_entire`).length,
          three_quarter: layers.flat().filter(b => b[3] === `${type}_three_quarter`).length,
          half: layers.flat().filter(b => b[3] === `${type}_half`).length,
          quarter: layers.flat().filter(b => b[3] === `${type}_quarter`).length,
        };
      });

      let html = '<table class="border-collapse border border-gray-400 w-full text-sm">';
      html += '<thead><tr class="bg-gray-200">';
      html += '<th class="border border-gray-400 p-2">Type</th>';
      html += '<th class="border border-gray-400 p-2">Enti√®re</th>';
      html += '<th class="border border-gray-400 p-2">Trois quarts</th>';
      html += '<th class="border border-gray-400 p-2">Demi</th>';
      html += '<th class="border border-gray-400 p-2">Quart</th>';
      html += '</tr></thead><tbody>';

      let hasNonZero = false;
      BRICK_TYPES.forEach(type => {
        const typeCounts = counts[type];
        if (Object.values(typeCounts).some(count => count > 0)) {
          hasNonZero = true;
          html += '<tr>';
          html += `<td class="border border-gray-400 p-2">${type}</td>`;
          html += `<td class="border border-gray-400 p-2">${typeCounts.entire}</td>`;
          html += `<td class="border border-gray-400 p-2">${typeCounts.three_quarter}</td>`;
          html += `<td class="border border-gray-400 p-2">${typeCounts.half}</td>`;
          html += `<td class="border border-gray-400 p-2">${typeCounts.quarter}</td>`;
          html += '</tr>';
        }
      });

      html += '</tbody></table>';
      document.getElementById('brick-type-counts').innerHTML = hasNonZero ? html : 'Aucun √©l√©ment plac√©';
    }

    function getBrickY(size) {
      return size[1] / 2 + jointThickness + currentLayer * (size[1] + jointThickness);
    }

    function saveState() {
      history = history.slice(0, historyIndex + 1);
      history.push({ layers: JSON.parse(JSON.stringify(layers)), projectTitle });
      historyIndex++;
    }

    function addBrick(point) {
      if (!point || point.x === undefined || point.z === undefined) return;
      const allPositions = layers.flat();
      const threshold = jointThickness + 0.001;
      const size = BRICK_SIZES[selectedSize];
      let snapX = Math.round(point.x * 100) / 100;
      let snapZ = Math.round(point.z * 100) / 100;
      let snappedX = snapX;
      let snappedZ = snapZ;

      for (const [x, , z] of allPositions) {
        if (Math.abs(snappedX - x) <= threshold) snappedX = x;
        if (Math.abs(snappedZ - z) <= threshold) snappedZ = z;
      }

      const y = getBrickY(size);
      const newBox = new THREE.Box3().setFromCenterAndSize(
        new THREE.Vector3(snappedX, y, snappedZ),
        new THREE.Vector3(size[0], size[1], size[2])
      );
      const rotationMatrix = new THREE.Matrix4().makeRotationY(rotationY);
      newBox.applyMatrix4(rotationMatrix);

      // Temporarily disable shadow plane to prevent shadow interference
      const originalShadowPlaneVisible = shadowPlane.visible;
      shadowPlane.visible = false;

      for (const [x, y2, z, type, rotY] of layers[currentLayer]) {
        if (y !== y2) continue;
        const existingBox = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(x, y2, z),
          new THREE.Vector3(BRICK_SIZES[type][0], BRICK_SIZES[type][1], BRICK_SIZES[type][2])
        );
        const existingRotation = new THREE.Matrix4().makeRotationY(rotY || 0);
        existingBox.applyMatrix4(existingRotation);
        if (newBox.intersectsBox(existingBox)) {
          const notification = document.getElementById('notification');
          notification.textContent = 'Erreur : Chevauchement d√©tect√©';
          notification.style.left = `${Math.min(window.innerWidth - 200, Math.max(0, mouse.x * window.innerWidth / 2 + window.innerWidth / 2 + 10))}px`;
          notification.style.top = `${-mouse.y * window.innerHeight / 2 + window.innerHeight / 2 + 10}px`;
          notification.style.display = 'block';
          setTimeout(() => notification.style.display = 'none', 2000);
          shadowPlane.visible = originalShadowPlaneVisible;
          return;
        }
      }

      // Restore shadow plane visibility
      shadowPlane.visible = originalShadowPlaneVisible;

      saveState();
      layers[currentLayer].push([snappedX, y, snappedZ, selectedSize, rotationY]);
      updateScene();
    }

    function deleteBrick() {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children.filter(child => child.isMesh && child !== plane && child !== shadowPlane));
      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const position = clickedMesh.position;
        saveState();
        for (let i = 0; i < layers.length; i++) {
          layers[i] = layers[i].filter(([x, y, z]) => {
            return !(Math.abs(x - position.x) < 0.001 && Math.abs(y - position.y) < 0.001 && Math.abs(z - position.z) < 0.001);
          });
        }
        deleteMode = false;
        document.querySelectorAll('#delete-mode').forEach(btn => btn.classList.remove('delete-active'));
        updateScene();
      }
    }

    function selectBrickForMove() {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children.filter(child => child.isMesh && child !== plane && child !== shadowPlane));
      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const layerIndex = clickedMesh.userData.layerIndex;
        const brickIndex = layers[layerIndex].findIndex(([x, y, z]) => 
          Math.abs(x - clickedMesh.position.x) < 0.001 && 
          Math.abs(y - clickedMesh.position.y) < 0.001 && 
          Math.abs(z - clickedMesh.position.z) < 0.001
        );
        selectedBrick = [...layers[layerIndex][brickIndex], layerIndex];
        layers[layerIndex].splice(brickIndex, 1);
        updateScene();
      }
    }

    function confirmMove(point) {
      if (!point || point.x === undefined || point.z === undefined) return;
      const threshold = jointThickness + 0.001;
      let snapX = Math.round(point.x * 100) / 100;
      let snapZ = Math.round(point.z * 100) / 100;
      const allPositions = layers.flat().filter(([x, y, z]) => !(Math.abs(x - selectedBrick[0]) < 0.001 && Math.abs(y - selectedBrick[1]) < 0.001 && Math.abs(z - selectedBrick[2]) < 0.001));
      for (const [x, , z] of allPositions) {
        if (Math.abs(snapX - x) <= threshold) snapX = x;
        if (Math.abs(snapZ - z) <= threshold) snapZ = z;
      }

      const y = selectedBrick[1];
      const newBox = new THREE.Box3().setFromCenterAndSize(
        new THREE.Vector3(snapX, y, snapZ),
        new THREE.Vector3(BRICK_SIZES[selectedBrick[3]][0], BRICK_SIZES[selectedBrick[3]][1], BRICK_SIZES[selectedBrick[3]][2])
      );
      const rotationMatrix = new THREE.Matrix4().makeRotationY(selectedBrick[4] || 0);
      newBox.applyMatrix4(rotationMatrix);

      // Temporarily disable shadow plane to prevent shadow interference
      const originalShadowPlaneVisible = shadowPlane.visible;
      shadowPlane.visible = false;

      for (const [x, y2, z, type, rotY] of layers[currentLayer]) {
        if (y !== y2) continue;
        const existingBox = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(x, y2, z),
          new THREE.Vector3(BRICK_SIZES[type][0], BRICK_SIZES[type][1], BRICK_SIZES[type][2])
        );
        const existingRotation = new THREE.Matrix4().makeRotationY(rotY || 0);
        existingBox.applyMatrix4(existingRotation);
        if (newBox.intersectsBox(existingBox)) {
          const notification = document.getElementById('notification');
          notification.textContent = 'Erreur : Chevauchement d√©tect√©';
          notification.style.left = `${Math.min(window.innerWidth - 200, Math.max(0, mouse.x * window.innerWidth / 2 + window.innerWidth / 2 + 10))}px`;
          notification.style.top = `${-mouse.y * window.innerHeight / 2 + window.innerHeight / 2 + 10}px`;
          notification.style.display = 'block';
          setTimeout(() => notification.style.display = 'none', 2000);
          layers[selectedBrick[5]].push([selectedBrick[0], selectedBrick[1], selectedBrick[2], selectedBrick[3], selectedBrick[4]]);
          selectedBrick = null;
          moveMode = false;
          document.querySelectorAll('#move-mode').forEach(btn => btn.classList.remove('move-active'));
          shadowPlane.visible = originalShadowPlaneVisible;
          updateScene();
          return;
        }
      }

      // Restore shadow plane visibility
      shadowPlane.visible = originalShadowPlaneVisible;

      saveState();
      layers[selectedBrick[5]].push([snapX, y, snapZ, selectedBrick[3], selectedBrick[4]]);
      selectedBrick = null;
      moveMode = false;
      document.querySelectorAll('#move-mode').forEach(btn => btn.classList.remove('move-active'));
      updateScene();
    }

    function selectBrickForRotate() {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children.filter(child => child.isMesh && child !== plane && child !== shadowPlane));
      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const layerIndex = clickedMesh.userData.layerIndex;
        const brickIndex = layers[layerIndex].findIndex(([x, y, z]) => 
          Math.abs(x - clickedMesh.position.x) < 0.001 && 
          Math.abs(y - clickedMesh.position.y) < 0.001 && 
          Math.abs(z - clickedMesh.position.z) < 0.001
        );
        selectedBrick = [...layers[layerIndex][brickIndex], layerIndex, brickIndex];
        const overlay = document.getElementById('rotate-overlay');
        overlay.style.display = 'block';
        document.getElementById('rotate-slider').value = (selectedBrick[4] || 0) * 180 / Math.PI;
        document.getElementById('rotate-value').textContent = `${Math.round((selectedBrick[4] || 0) * 180 / Math.PI)}¬∞`;
      }
    }

    function confirmRotation() {
      const newRotation = (document.getElementById('rotate-slider').value * Math.PI) / 180;
      saveState();
      layers[selectedBrick[5]][selectedBrick[6]][4] = newRotation;
      selectedBrick = null;
      rotateMode = false;
      document.querySelectorAll('#rotate-mode').forEach(btn => btn.classList.remove('rotate-active'));
      document.getElementById('rotate-overlay').style.display = 'none';
      updateScene();
    }

    function addLayer() {
      saveState();
      layers.push([]);
      currentLayer = layers.length - 1;
      updateLayerSelect();
      updateScene();
    }

    function undo() {
      if (historyIndex <= 0) return;
      historyIndex--;
      layers = JSON.parse(JSON.stringify(history[historyIndex].layers));
      projectTitle = history[historyIndex].projectTitle;
      document.getElementById('project-title').value = projectTitle;
      updateLayerSelect();
      updateScene();
    }

    function redo() {
      if (historyIndex >= history.length - 1) return;
      historyIndex++;
      layers = JSON.parse(JSON.stringify(history[historyIndex].layers));
      projectTitle = history[historyIndex].projectTitle;
      document.getElementById('project-title').value = projectTitle;
      updateLayerSelect();
      updateScene();
    }

    function resetCamera() {
      camera.position.set(0.5, 0.5, 1);
      controls.target.set(0, 0, 0);
      controls.update();
      renderer.render(scene, camera);
    }

    function exportPDF() {
      const originalWidth = window.innerWidth;
      const originalHeight = window.innerHeight;
      const exportWidth = 1920;
      const exportHeight = Math.round(exportWidth * (27.7 / 21)); // Aspect ratio 21/27.7 ‚âà 0.758
      const pdf = new jsPDF({ orientation: 'landscape', unit: 'cm', format: [29.7, 21] });
      const width = pdf.internal.pageSize.getWidth();
      const height = pdf.internal.pageSize.getHeight();
      const appTitle = projectTitle || 'Mur Simulateur 3d';
      const versionText = 'Version 1.0.0';
      let page = 1;

      renderer.setSize(exportWidth, exportHeight);
      renderer.setClearColor(0xffffff, 1);

      let minX = 0, maxX = 0, minZ = 0, maxZ = 0, maxY = 0;
      layers.flat().forEach(([x, y, z, type]) => {
        const size = BRICK_SIZES[type];
        minX = Math.min(minX, x - size[0] / 2);
        maxX = Math.max(maxX, x + size[0] / 2);
        minZ = Math.min(minZ, z - size[2] / 2);
        maxZ = Math.max(maxZ, z + size[2] / 2);
        maxY = Math.max(maxY, y + size[1] / 2);
      });
      const centerX = (minX + maxX) / 2;
      const centerZ = (minZ + maxZ) / 2;
      const centerY = maxY / 2;

      function addCommonElements(viewName, isFourthPage = false) {
        pdf.setLineWidth(0.05);
        pdf.line(1, height - 2, 1 + 1, height - 2);
        pdf.setFontSize(8);
        pdf.text('10 cm', 1, height - 1.5);
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(16);
        if (isFourthPage) {
          pdf.text(appTitle, width / 2, 3.5, { align: 'center' });
        } else {
          pdf.text(appTitle, width / 2, 0.5, { align: 'center' });
        }
        pdf.setFontSize(12);
        if (isFourthPage) {
          pdf.text(viewName, width / 2, height - 3.5, { align: 'center' });
        } else {
          pdf.text(viewName, width / 2, height - 1, { align: 'center' });
        }
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(8);
        if (isFourthPage) {
          pdf.text(appTitle, width - 1.5, height - 4.5, { align: 'right' });
          pdf.text('Con√ßu par Julien BROHEZ', width - 1.5, height - 4, { align: 'right' });
          pdf.text(versionText, width - 1.5, height - 3.5, { align: 'right' });
          pdf.text(`${page} sur 5`, 1.5, height - 3.5);
        } else {
          pdf.text(appTitle, width - 3, height - 1.5, { align: 'right' });
          pdf.text('Con√ßu par Julien BROHEZ', width - 3, height - 1, { align: 'right' });
          pdf.text(versionText, width - 3, height - 0.5, { align: 'right' });
          pdf.text(`${page} sur 5`, 1, height - 0.5);
        }
      }

      function addMarginMarks() {
        pdf.setLineWidth(0.02);
        pdf.line(1, 10, 1, 11);
        pdf.line(28.7, 10, 28.7, 11);
        pdf.line(14.35, 1, 15.35, 1);
        pdf.line(14.35, 20, 15.35, 20);
      }

      // Top view (1:10 scale, no shadows, no ground plane)
      renderer.shadowMap.enabled = false;
      const originalPlaneVisible = plane.visible;
      const originalShadowPlaneVisible = shadowPlane.visible;
      plane.visible = false;
      shadowPlane.visible = false;
      scene.background = null;
      const topCamera = new THREE.OrthographicCamera(
        -0.722, 0.722, // 1.444 meters width (14.44 cm √ó 10)
        0.95, -0.95, // 1.9 meters height (19 cm √ó 10)
        0.1, 100
      );
      topCamera.position.set(centerX, 1, centerZ);
      topCamera.lookAt(centerX, 0, centerZ);
      renderer.render(scene, topCamera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 7.63, 1, 14.44, 19);
      plane.visible = originalPlaneVisible;
      shadowPlane.visible = originalShadowPlaneVisible;
      addMarginMarks();
      addCommonElements('Vue de dessus');
      pdf.text('√âchelle : 1/10', 1, height - 1);
      page++;

      // Front view (1:10 scale)
      pdf.addPage();
      const frontLineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-0.722, 0, 0),
        new THREE.Vector3(0.722, 0, 0)
      ]);
      const frontLineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 5 });
      const frontLine = new THREE.Line(frontLineGeometry, frontLineMaterial);
      scene.add(frontLine);
      renderer.shadowMap.enabled = true;
      const frontCamera = new THREE.OrthographicCamera(
        -0.722, 0.722, // 1.444 meters width
        0.95, -0.95, // 1.9 meters height
        0.1, 100
      );
      frontCamera.position.set(centerX, centerY, 0.722);
      frontCamera.lookAt(centerX, centerY, 0);
      renderer.render(scene, frontCamera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 7.63, 1, 14.44, 19);
      addMarginMarks();
      addCommonElements('Vue de face');
      pdf.text('√âchelle : 1/10', 1, height - 1);
      scene.remove(frontLine);
      page++;

      // Side view (1:10 scale)
      pdf.addPage();
      const sideLineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, -0.95),
        new THREE.Vector3(0, 0, 0.95)
      ]);
      const sideLineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 5 });
      const sideLine = new THREE.Line(sideLineGeometry, sideLineMaterial);
      scene.add(sideLine);
      const sideCamera = new THREE.OrthographicCamera(
        -0.722, 0.722, // 1.444 meters width
        0.95, -0.95, // 1.9 meters height
        0.1, 100
      );
      sideCamera.position.set(0.722, centerY, centerZ);
      sideCamera.lookAt(0, centerY, centerZ);
      renderer.render(scene, sideCamera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 7.63, 1, 14.44, 19);
      addMarginMarks();
      addCommonElements('Vue de c√¥t√©');
      pdf.text('√âchelle : 1/10', 1, height - 1);
      scene.remove(sideLine);
      page++;

      // 3D view
      pdf.addPage();
      renderer.shadowMap.enabled = true;
      scene.background = skyTexture;
      camera.aspect = exportWidth / exportHeight;
      camera.updateProjectionMatrix();
      camera.lookAt(controls.target);
      renderer.render(scene, camera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 7.63, 1, 14.44, 19);
      addMarginMarks();
      addCommonElements('Vue 3D', true);
      page++;

      // Inventory page
      pdf.addPage();
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(16);
      pdf.text(appTitle, width / 2, 0.5, { align: 'center' });
      pdf.setFontSize(12);
      pdf.text('Inventaire des √©l√©ments', width / 2, 1, { align: 'center' });
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(10);
      let y = 2;
      BRICK_TYPES.forEach(type => {
        SIZE_VARIANTS.forEach(variant => {
          const count = layers.flat().filter(b => b[3] === `${type}_${variant}`).length;
          if (count > 0) {
            pdf.text(`${type} (${variant}): ${count} √©l√©ments`, 1, y);
            y += 1;
          }
        });
      });
      pdf.setFontSize(8);
      pdf.text(appTitle, width - 3, height - 1.5, { align: 'right' });
      pdf.text('Con√ßu par Julien BROHEZ', width - 3, height - 1, { align: 'right' });
      pdf.text(versionText, width - 3, height - 0.5, { align: 'right' });
      pdf.text(`${page} sur 5`, 1, height - 0.5);

      renderer.setSize(originalWidth, originalHeight);
      camera.aspect = originalWidth / originalHeight;
      camera.updateProjectionMatrix();
      renderer.shadowMap.enabled = true;
      scene.background = skyTexture;
      renderer.setClearColor(0x000000, 0);

      pdf.save('vue-elements.pdf');
    }

    function exportPNG() {
      if (projectTitle) {
        const canvas = document.createElement('canvas');
        canvas.width = renderer.domElement.width;
        canvas.height = renderer.domElement.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(renderer.domElement, 0, 0);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, 50);
        ctx.fillStyle = '#000000';
        ctx.font = 'bold 30px Helvetica';
        ctx.textAlign = 'center';
        ctx.fillText(projectTitle, canvas.width / 2, 40);
        const link = document.createElement('a');
        link.download = 'vue-elements.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      } else {
        renderer.render(scene, camera);
        const link = document.createElement('a');
        link.download = 'vue-elements.png';
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();
      }
    }

    function updateLayerSelect() {
      const select = document.getElementById('layer-select');
      select.innerHTML = '';
      layers.forEach((_, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Assise ${i + 1}`;
        if (i === currentLayer) option.selected = true;
        select.appendChild(option);
      });
    }

    function makeDraggable(element, pos) {
      let isDragging = false;
      let startX, startY;

      element.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'LABEL' || e.target.tagName === 'INPUT') return;
        isDragging = true;
        startX = e.clientX - pos.x;
        startY = e.clientY - pos.y;
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        let x = e.clientX - startX;
        let y = e.clientY - startY;

        if (element.id === 'layerbox') {
          y = Math.max(360, Math.min(y, 410));
          x = Math.max(0, Math.min(x, window.innerWidth - element.offsetWidth));
        } else if (element.id === 'title-input') {
          y = Math.max(50, Math.min(y, 100));
          x = Math.max(0, Math.min(x, window.innerWidth - element.offsetWidth));
        }

        pos.x = x;
        pos.y = y;
        element.style.left = `${x}px`;
        element.style.top = `${y}px`;
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    }

    function saveFile() {
      const data = JSON.stringify({ layers, projectTitle });
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'wall-design.json';
      link.click();
      URL.revokeObjectURL(url);
    }

    function openFile() {
      document.getElementById('file-input').click();
    }

    function validateLayers(data) {
      if (!data || typeof data !== 'object') return false;
      const { layers, projectTitle } = data;
      return (
        Array.isArray(layers) &&
        layers.every(layer => Array.isArray(layer) && layer.every(([x, y, z, type, rotY]) => 
          typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && 
          BRICK_SIZES[type] && (rotY === undefined || typeof rotY === 'number')
        )) &&
        (typeof projectTitle === 'string' || projectTitle === undefined)
      );
    }

    function setupEventListeners() {
      document.getElementById('project-title').addEventListener('input', (e) => {
        projectTitle = e.target.value.slice(0, 100);
        saveState();
      });
      document.getElementById('brick-type').addEventListener('change', (e) => {
        const brickType = e.target.value;
        const sizeVariant = document.getElementById('brick-size').value;
        selectedSize = `${brickType}_${sizeVariant}`;
        updateScene();
      });
      document.getElementById('brick-size').addEventListener('change', (e) => {
        const sizeVariant = e.target.value;
        const brickType = document.getElementById('brick-type').value;
        selectedSize = `${brickType}_${sizeVariant}`;
        updateScene();
      });
      document.getElementById('rotation-y').addEventListener('input', (e) => {
        rotationY = (e.target.value * Math.PI) / 180;
        document.getElementById('rotation-value').textContent = `${e.target.value}¬∞`;
        updateScene();
      });
      document.getElementById('joint-thickness').addEventListener('input', (e) => {
        jointThickness = parseFloat(e.target.value) / 100;
        updateScene();
      });
      document.getElementById('layer-select').addEventListener('change', (e) => {
        currentLayer = parseInt(e.target.value);
        updateScene();
      });
      document.getElementById('add-layer').addEventListener('click', addLayer);
      document.querySelectorAll('#delete-mode').forEach(btn => {
        btn.addEventListener('click', () => {
          deleteMode = !deleteMode;
          moveMode = false;
          rotateMode = false;
          selectedBrick = null;
          document.querySelectorAll('#delete-mode').forEach(b => b.classList.toggle('delete-active', deleteMode));
          document.querySelectorAll('#move-mode').forEach(b => b.classList.remove('move-active'));
          document.querySelectorAll('#rotate-mode').forEach(b => b.classList.remove('rotate-active'));
          document.getElementById('rotate-overlay').style.display = 'none';
          updateScene();
        });
      });
      document.querySelectorAll('#move-mode').forEach(btn => {
        btn.addEventListener('click', () => {
          moveMode = !moveMode;
          deleteMode = false;
          rotateMode = false;
          selectedBrick = null;
          document.querySelectorAll('#move-mode').forEach(b => b.classList.toggle('move-active', moveMode));
          document.querySelectorAll('#delete-mode').forEach(b => b.classList.remove('delete-active'));
          document.querySelectorAll('#rotate-mode').forEach(b => b.classList.remove('rotate-active'));
          document.getElementById('rotate-overlay').style.display = 'none';
          updateScene();
        });
      });
      document.querySelectorAll('#rotate-mode').forEach(btn => {
        btn.addEventListener('click', () => {
          rotateMode = !rotateMode;
          deleteMode = false;
          moveMode = false;
          selectedBrick = null;
          document.querySelectorAll('#rotate-mode').forEach(b => b.classList.toggle('rotate-active', rotateMode));
          document.querySelectorAll('#delete-mode').forEach(b => b.classList.remove('delete-active'));
          document.querySelectorAll('#move-mode').forEach(b => b.classList.remove('move-active'));
          document.getElementById('rotate-overlay').style.display = 'none';
          updateScene();
        });
      });
      document.getElementById('rotate-slider').addEventListener('input', (e) => {
        document.getElementById('rotate-value').textContent = `${e.target.value}¬∞`;
      });
      document.getElementById('confirm-rotation').addEventListener('click', confirmRotation);
      document.getElementById('save-file').addEventListener('click', saveFile);
      document.getElementById('open-file').addEventListener('click', openFile);
      document.getElementById('file-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);
            if (validateLayers(data)) {
              layers = data.layers;
              projectTitle = data.projectTitle || '';
              document.getElementById('project-title').value = projectTitle;
              currentLayer = Math.min(currentLayer, layers.length - 1);
              history = [{ layers: JSON.parse(JSON.stringify(layers)), projectTitle }];
              historyIndex = 0;
              updateLayerSelect();
              updateScene();
            } else {
              const notification = document.getElementById('notification');
              notification.textContent = 'Erreur : Format de fichier invalide';
              notification.style.left = `${window.innerWidth / 2}px`;
              notification.style.top = `${window.innerHeight / 2}px`;
              notification.style.display = 'block';
              setTimeout(() => notification.style.display = 'none', 2000);
            }
          } catch (err) {
            const notification = document.getElementById('notification');
            notification.textContent = `Erreur : ${err.message}`;
            notification.style.left = `${window.innerWidth / 2}px`;
            notification.style.top = `${window.innerHeight / 2}px`;
            notification.style.display = 'block';
            setTimeout(() => notification.style.display = 'none', 2000);
          }
        };
        reader.readAsText(file);
        e.target.value = '';
      });
      document.getElementById('export-pdf').addEventListener('click', exportPDF);
      document.getElementById('export-png').addEventListener('click', exportPNG);
      document.getElementById('toggle-white-bricks').addEventListener('click', () => {
        whiteBricks = !whiteBricks;
        updateScene();
      });
      document.getElementById('toggle-grid').addEventListener('click', () => {
        gridHelper.visible = !gridHelper.visible;
        renderer.render(scene, camera);
      });
      document.getElementById('reset-camera').addEventListener('click', resetCamera);

      document.addEventListener('mousemove', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(plane);
        if (intersects.length > 0 && !deleteMode && !rotateMode) {
          hoverPoint = intersects[0].point;
        } else {
          hoverPoint = null;
        }
        updateScene();
      });

      document.addEventListener('click', (e) => {
        if (deleteMode) {
          deleteBrick();
        } else if (moveMode) {
          if (!selectedBrick) {
            selectBrickForMove();
          } else {
            const intersects = raycaster.intersectObject(plane);
            if (intersects.length > 0) {
              confirmMove(intersects[0].point);
            }
          }
        } else if (rotateMode && !selectedBrick) {
          selectBrickForRotate();
        }
      });

      document.addEventListener('dblclick', (e) => {
        if (!deleteMode && !moveMode && !rotateMode) {
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(plane);
          if (intersects.length > 0) {
            addBrick(intersects[0].point);
          }
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        titleInputPos.x = window.innerWidth / 2 - document.getElementById('title-input').offsetWidth / 2;
        document.getElementById('title-input').style.left = `${titleInputPos.x}px`;
      });
    }

    document.getElementById('start-button').addEventListener('click', () => {
      document.getElementById('homepage').style.display = 'none';
      document.getElementById('app').style.display = 'block';
      initThreeJS();
      setupEventListeners();
      updateLayerSelect();
      animate();
    });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
