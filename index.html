<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wall Simulateur 3d</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #ffffff; color: #000000; font-family: Arial, sans-serif; }
    canvas { width: 100%; height: 100vh; }
    .toolbox, .layerbox, .actions, .brick-counter, .title, .version { position: absolute; background: #e2e8f0; padding: 8px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); z-index: 10; }
    .toolbox { top: 10px; left: 10px; width: 256px; }
    .layerbox { top: 100px; left: 50%; transform: translateX(-50%); cursor: move; width: auto; max-width: 600px; display: flex; flex-direction: column; align-items: center; gap: 8px; pointer-events: none; }
    .layerbox * { pointer-events: auto; }
    .actions { top: 10px; right: 10px; width: 256px; }
    .brick-counter { bottom: 10px; right: 10px; width: 200px; }
    .title { top: 10px; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; }
    .title h1 { font-size: 24px; margin: 0; }
    .title p { font-size: 14px; margin: 4px 0 0; }
    .version { bottom: 10px; left: 10px; font-size: 12px; padding: 8px; }
    .grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
    button { padding: 4px; border-radius: 4px; border: none; cursor: pointer; font-size: 12px; font-weight: bold; color: #000000; }
    button:hover { opacity: 0.8; }
    .delete-active { background-color: #b7791f !important; }
    input, select { background: #edf2f7; color: #000000; border: none; padding: 4px; border-radius: 4px; }
    label { font-size: 14px; margin-right: 8px; }
    h2 { font-size: 18px; margin-bottom: 8px; color: #000000; }
    .brick-count, .brick-type-count { font-size: 14px; }
    #homepage { display: flex; }
    #app { display: none; }
    #notification { display: none; }
  </style>
</head>
<body>
  <div id="notification" class="absolute bg-red-600 text-white px-4 py-2 rounded-lg" style="display: none; z-index: 20;"></div>
  <div id="homepage" class="flex flex-col items-center justify-center h-screen">
    <h1 class="text-5xl font-bold text-black">Wall Simulateur 3d</h1>
    <p class="text-lg text-black mt-2">Made by Julien BROHEZ</p>
    <p class="text-lg text-black mt-2">Version 1.0.0</p>
    <button id="start-button" class="mt-6 bg-green-600 text-white px-6 py-3 text-lg rounded-lg hover:bg-green-700 transition">Commencer</button>
  </div>
  <div id="app">
    <div id="title" class="title">
      <h1>Wall Simulateur 3d</h1>
      <p>Cr√©√© par Julien BROHEZ</p>
    </div>
    <div id="toolbox" class="toolbox">
      <h2>üß± Outils de pose</h2>
      <label>Type de brique</label>
      <div class="grid">
        <button id="brick-entire" style="background-color: #e07b39;" title="Enti√®re - 19x9x5">1/1</button>
        <button id="brick-three_quarter" style="background-color: #3498db;" title="Trois quarts - 14x9x5">3/4</button>
        <button id="brick-half" style="background-color: #2ecc71;" title="Demi - 9x9x5">1/2</button>
        <button id="brick-quarter" style="background-color: #9b59b6;" title="Quart - 4x9x5">1/4</button>
      </div>
      <label>Rotation Y (¬∞)</label>
      <input type="range" id="rotation-y" min="0" max="355" step="15" value="0">
      <div id="rotation-value" style="text-align: center; font-size: 12px;">0¬∞</div>
      <label>√âpaisseur du joint (cm)</label>
      <input type="number" id="joint-thickness" min="0" step="0.1" value="1">
      <label>Couleur des briques</label>
      <div style="display: flex; align-items: center; gap: 8px;">
        <input type="checkbox" id="show-colors" checked>
        <span style="font-size: 14px;">Afficher les couleurs</span>
      </div>
      <div style="display: flex; align-items: center; gap: 8px; margin-top: 8px;">
        <input type="checkbox" id="white-bricks">
        <span style="font-size: 14px;">Afficher en blanc</span>
      </div>
      <div style="display: flex; align-items: center; gap: 8px; margin-top: 8px;">
        <input type="checkbox" id="show-grid">
        <span style="font-size: 14px;">Afficher la grille</span>
      </div>
      <button id="delete-mode" style="background-color: #d69e2e; margin-top: 8px;">üóëÔ∏è Effacer</button>
    </div>
    <div id="layerbox" class="layerbox">
      <div style="display: flex; align-items: center; gap: 12px;">
        <label>Assise active</label>
        <select id="layer-select"></select>
        <button id="add-layer" style="background-color: #3182ce;">‚ûï</button>
      </div>
      <div id="brick-count" class="brick-count" style="margin-top: 8px; text-align: center;">Assise active: 0 | Total: 0</div>
    </div>
    <div class="actions">
      <h2>üìÑ Actions</h2>
      <button id="undo" style="background-color: #e53e3e;">‚Ü©Ô∏è Annuler</button>
      <button id="redo" style="background-color: #e53e3e; margin-top: 8px;">‚Ü™Ô∏è Refaire</button>
      <button id="save-file" style="background-color: #38a169; margin-top: 8px;">üíæ Enregistrer</button>
      <button id="open-file" style="background-color: #3182ce; margin-top: 8px;">üìÇ Ouvrir</button>
      <input type="file" id="file-input" accept=".json" style="display: none;">
      <button id="export-pdf" style="background-color: #38a169; margin-top: 8px;">üìÑ Exporter PDF</button>
      <button id="export-png" style="background-color: #3182ce; margin-top: 8px;">üñºÔ∏è Exporter PNG</button>
    </div>
    <div id="brick-counter" class="brick-counter">
      <h2>üßÆ Compteur de briques</h2>
      <div id="brick-type-counts" class="brick-type-count">
        <div>Enti√®re: 0</div>
        <div>Trois quarts: 0</div>
        <div>Demi: 0</div>
        <div>Quart: 0</div>
      </div>
    </div>
    <div id="version" class="version">Version 1.0.0</div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    const { jsPDF } = window.jspdf;

    // Constants
    const BRICK_SIZES = {
      entire: [0.19, 0.05, 0.09],
      three_quarter: [0.14, 0.05, 0.09],
      half: [0.09, 0.05, 0.09],
      quarter: [0.04, 0.05, 0.09],
    };
    const COLOR_MAP = {
      entire: '#e07b39',
      three_quarter: '#3498db',
      half: '#2ecc71',
      quarter: '#9b59b6',
    };

    // State
    let layers = [[/* assise 0 */]];
    let currentLayer = 0;
    let selectedSize = 'entire';
    let hoverPoint = null;
    let jointThickness = 0.01;
    let rotationY = 0;
    let showColors = true;
    let whiteBricks = false;
    let deleteMode = false;
    let layerboxPos = { x: window.innerWidth / 2 - 150, y: 100 };
    let history = [{ layers: JSON.parse(JSON.stringify(layers)) }];
    let historyIndex = 0;

    // Three.js Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0.5, 0.5, 1);
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.shadowMap.autoUpdate = false;

    // Gradient Sky
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const context = canvas.getContext('2d');
    const gradient = context.createLinearGradient(0, 0, 0, 512);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(1, '#FFFFFF');
    context.fillStyle = gradient;
    context.fillRect(0, 0, 512, 512);
    const skyTexture = new THREE.CanvasTexture(canvas);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(1, 2, 2);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.left = -2;
    directionalLight.shadow.camera.right = 2;
    directionalLight.shadow.camera.top = 2;
    directionalLight.shadow.camera.bottom = -2;
    directionalLight.shadow.camera.near = 0.1;
    directionalLight.shadow.camera.far = 10;

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = true;
    controls.enableZoom = true;
    controls.enableRotate = true;

    // Ground Plane (Visible Floor)
    const planeGeometry = new THREE.PlaneGeometry(4, 4);
    const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xf0f0f0, visible: true });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;

    // Shadow Plane
    const shadowMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
    const shadowPlane = new THREE.Mesh(planeGeometry, shadowMaterial);
    shadowPlane.rotation.x = -Math.PI / 2;
    shadowPlane.receiveShadow = true;

    // Grid Helper
    const gridHelper = new THREE.GridHelper(4, 400, 0x000000, 0x000000);
    gridHelper.material.opacity = 0.2;
    gridHelper.material.transparent = true;
    gridHelper.visible = false;

    // Raycaster for mouse interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // Initialize Three.js after clicking "Commencer"
    function initThreeJS() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('app').appendChild(renderer.domElement);
      scene.background = skyTexture;
      scene.add(ambientLight, directionalLight, plane, shadowPlane, gridHelper);
    }

    // Create Brick
    function createBrick(position, size, type, transparent = false, highlight = false, rotation = [0, 0, 0], isColliding = false) {
      const geometry = new THREE.BoxGeometry(...size);
      const color = transparent ? (isColliding ? '#ff0000' : '#00ff00') : (whiteBricks ? '#ffffff' : (highlight ? '#00ffff' : (showColors ? (COLOR_MAP[type] || 'orange') : '#999')));
      const material = new THREE.MeshStandardMaterial({
        color,
        transparent,
        opacity: transparent ? 0.3 : 1,
        wireframe: transparent,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(...position);
      mesh.rotation.set(...rotation);
      mesh.castShadow = !transparent;
      mesh.receiveShadow = true;

      if (!transparent) {
        const edges = new THREE.EdgesGeometry(geometry);
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });
        const edgeLines = new THREE.LineSegments(edges, edgeMaterial);
        edgeLines.position.set(...position);
        edgeLines.rotation.set(...rotation);
        mesh.userData.edges = edgeLines;
      }

      return mesh;
    }

    // Update Scene Bricks
    function updateScene() {
      scene.children = scene.children.filter(child => !child.isMesh && !child.isLineSegments || child === plane || child === shadowPlane || child === gridHelper);
      let hoveredBrick = null;
      if (deleteMode) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children.filter(child => child.isMesh && child !== plane && child !== shadowPlane));
        if (intersects.length > 0) {
          hoveredBrick = intersects[0].object;
        }
      }
      layers.flat().forEach(([x, y, z, type, rotY]) => {
        const isHovered = deleteMode && hoveredBrick && Math.abs(hoveredBrick.position.x - x) < 0.001 && Math.abs(hoveredBrick.position.y - y) < 0.001 && Math.abs(hoveredBrick.position.z - z) < 0.001;
        const brick = createBrick([x, y, z], BRICK_SIZES[type], type, false, isHovered, [0, rotY || 0, 0]);
        scene.add(brick);
        if (brick.userData.edges) scene.add(brick.userData.edges);
      });
      if (hoverPoint && !deleteMode && hoverPoint.x !== undefined && hoverPoint.z !== undefined) {
        let snapX = Math.round(hoverPoint.x * 100) / 100;
        let snapZ = Math.round(hoverPoint.z * 100) / 100;
        const threshold = jointThickness + 0.001;
        const allPositions = layers.flat();
        for (const [x, , z] of allPositions) {
          if (Math.abs(snapX - x) <= threshold) snapX = x;
          if (Math.abs(snapZ - z) <= threshold) snapZ = z;
        }
        console.log('Hover brick position:', { snapX, snapZ });
        const y = getBrickY(BRICK_SIZES[selectedSize]);
        let isColliding = false;
        const newBox = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(snapX, y, snapZ),
          new THREE.Vector3(BRICK_SIZES[selectedSize][0], BRICK_SIZES[selectedSize][1], BRICK_SIZES[selectedSize][2])
        );
        newBox.applyMatrix4(new THREE.Matrix4().makeRotationY(rotationY));
        for (const [x, y2, z, type, rotY] of layers[currentLayer]) {
          if (y !== y2) continue;
          const existingBox = new THREE.Box3().setFromCenterAndSize(
            new THREE.Vector3(x, y2, z),
            new THREE.Vector3(BRICK_SIZES[type][0], BRICK_SIZES[type][1], BRICK_SIZES[type][2])
          );
          existingBox.applyMatrix4(new THREE.Matrix4().makeRotationY(rotY || 0));
          if (newBox.intersectsBox(existingBox)) {
            isColliding = true;
            break;
          }
        }
        const hoverBrick = createBrick([snapX, y, snapZ], BRICK_SIZES[selectedSize], selectedSize, true, false, [0, rotationY, 0], isColliding);
        scene.add(hoverBrick);
      } else {
        console.log('Hover point invalid:', hoverPoint);
      }
      updateBrickCount();
      renderer.shadowMap.needsUpdate = true;
    }

    // Update Brick Count
    function updateBrickCount() {
      const currentCount = layers[currentLayer].length;
      const totalCount = layers.reduce((sum, layer) => sum + layer.length, 0);
      document.getElementById('brick-count').textContent = `Assise active: ${currentCount} | Total: ${totalCount}`;

      const counts = {
        entire: layers.flat().filter(b => b[3] === 'entire').length,
        three_quarter: layers.flat().filter(b => b[3] === 'three_quarter').length,
        half: layers.flat().filter(b => b[3] === 'half').length,
        quarter: layers.flat().filter(b => b[3] === 'quarter').length,
      };
      document.getElementById('brick-type-counts').innerHTML = `
        <div>Enti√®re: ${counts.entire}</div>
        <div>Trois quarts: ${counts.three_quarter}</div>
        <div>Demi: ${counts.half}</div>
        <div>Quart: ${counts.quarter}</div>
      `;
    }

    // Get Brick Y Position
    function getBrickY(size) {
      return size[1] / 2 + jointThickness + currentLayer * (size[1] + jointThickness);
    }

    // Save History State
    function saveState() {
      history = history.slice(0, historyIndex + 1);
      history.push({ layers: JSON.parse(JSON.stringify(layers)) });
      historyIndex++;
      console.log('State saved:', { historyIndex, historyLength: history.length });
    }

    // Add Brick with Collision Detection
    function addBrick(point) {
      if (!point || point.x === undefined || point.z === undefined) {
        console.error('Invalid point for addBrick:', point);
        return;
      }
      const allPositions = layers.flat();
      const threshold = jointThickness + 0.001;
      const size = BRICK_SIZES[selectedSize];
      let snapX = Math.round(point.x * 100) / 100;
      let snapZ = Math.round(point.z * 100) / 100;
      let snappedX = snapX;
      let snappedZ = snapZ;

      for (const [x, , z] of allPositions) {
        if (Math.abs(snappedX - x) <= threshold) snappedX = x;
        if (Math.abs(snappedZ - z) <= threshold) snappedZ = z;
      }

      const y = getBrickY(size);
      console.log('Adding brick at:', { snappedX, y, snappedZ });

      // Collision detection
      const newBox = new THREE.Box3().setFromCenterAndSize(
        new THREE.Vector3(snappedX, y, snappedZ),
        new THREE.Vector3(size[0], size[1], size[2])
      );
      const rotationMatrix = new THREE.Matrix4().makeRotationY(rotationY);
      newBox.applyMatrix4(rotationMatrix);

      for (const [x, y2, z, type, rotY] of layers[currentLayer]) {
        if (y !== y2) continue; // Same layer only
        const existingBox = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(x, y2, z),
          new THREE.Vector3(BRICK_SIZES[type][0], BRICK_SIZES[type][1], BRICK_SIZES[type][2])
        );
        const existingRotation = new THREE.Matrix4().makeRotationY(rotY || 0);
        existingBox.applyMatrix4(existingRotation);
        if (newBox.intersectsBox(existingBox)) {
          const notification = document.getElementById('notification');
          notification.textContent = 'Erreur : Chevauchement d√©tect√©';
          notification.style.left = `${Math.min(window.innerWidth - 200, Math.max(0, mouse.x * window.innerWidth / 2 + window.innerWidth / 2 + 10))}px`;
          notification.style.top = `${-mouse.y * window.innerHeight / 2 + window.innerHeight / 2 + 10}px`;
          notification.style.display = 'block';
          setTimeout(() => notification.style.display = 'none', 2000);
          console.warn('Collision detected, brick not added:', { snappedX, y, snappedZ });
          return;
        }
      }

      saveState();
      layers[currentLayer].push([snappedX, y, snappedZ, selectedSize, rotationY]);
      updateScene();
    }

    // Delete Brick
    function deleteBrick() {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children.filter(child => child.isMesh && child !== plane && child !== shadowPlane));
      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const position = clickedMesh.position;
        saveState();
        for (let i = 0; i < layers.length; i++) {
          layers[i] = layers[i].filter(([x, y, z]) => {
            return !(Math.abs(x - position.x) < 0.001 && Math.abs(y - position.y) < 0.001 && Math.abs(z - position.z) < 0.001);
          });
        }
        deleteMode = false;
        document.getElementById('delete-mode').classList.remove('delete-active');
        updateScene();
      }
    }

    // Add Layer
    function addLayer() {
      saveState();
      layers.push([]);
      currentLayer = layers.length - 1;
      updateLayerSelect();
      updateScene();
    }

    // Undo
    function undo() {
      if (!history || historyIndex <= 0) {
        console.warn('Cannot undo: history is undefined or at start');
        return;
      }
      historyIndex--;
      layers = JSON.parse(JSON.stringify(history[historyIndex].layers));
      updateLayerSelect();
      updateScene();
      console.log('Undo:', { historyIndex, historyLength: history.length });
    }

    // Redo
    function redo() {
      if (!history || historyIndex >= (history.length - 1)) {
        console.warn('Cannot redo: history is undefined or at end');
        return;
      }
      historyIndex++;
      layers = JSON.parse(JSON.stringify(history[historyIndex].layers));
      updateLayerSelect();
      updateScene();
      console.log('Redo:', { historyIndex, historyLength: history.length });
    }

    // Export PDF
    function exportPDF() {
      const originalWidth = window.innerWidth;
      const originalHeight = window.innerHeight;
      const exportWidth = 1920;
      const exportHeight = exportWidth * (originalHeight / originalWidth);

      const pdf = new jsPDF({ orientation: 'landscape', unit: 'cm', format: [21, 29.7] });
      const width = pdf.internal.pageSize.getWidth();
      const height = pdf.internal.pageSize.getHeight();

      renderer.setSize(exportWidth, exportHeight);
      renderer.setClearColor(0xffffff, 1);

      // Page 1: Top view
      let minX = 0, maxX = 0, minZ = 0, maxZ = 0;
      layers.flat().forEach(([x, , z]) => {
        minX = Math.min(minX, x - 0.19 / 2);
        maxX = Math.max(maxX, x + 0.19 / 2);
        minZ = Math.min(minZ, z - 0.19 / 2);
        maxZ = Math.max(maxZ, z + 0.19 / 2);
      });
      const padding = 0.1;
      const topWidth = Math.max(2, maxX - minX + padding);
      const topHeight = Math.max(2, maxZ - minZ + padding);
      renderer.shadowMap.enabled = false;
      scene.background = null;
      const topCamera = new THREE.OrthographicCamera(-topWidth / 2, topWidth / 2, topHeight / 2, -topHeight / 2, 0.1, 100);
      topCamera.position.set(0, 1, 0);
      topCamera.lookAt(0, 0, 0);
      renderer.render(scene, topCamera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 0, 0, width, height);
      pdf.setLineWidth(0.05);
      pdf.line(1, height - 2, 1 + 1, height - 2);
      pdf.setFontSize(8);
      pdf.text('100 cm', 1, height - 1.5);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Vue de dessus', width / 2, height - 1, { align: 'center' });
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.text('Wall Simulateur 3d', width - 3, height - 1.5, { align: 'right' });
      pdf.text('Made by Julien BROHEZ', width - 3, height - 1, { align: 'right' });

      // Page 2: Front view
      pdf.addPage();
      const frontLineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-2, 0, 0),
        new THREE.Vector3(2, 0, 0)
      ]);
      const frontLineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 5 });
      const frontLine = new THREE.Line(frontLineGeometry, frontLineMaterial);
      scene.add(frontLine);
      scene.background = null;
      const frontCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 100);
      frontCamera.position.set(0, 0.5, 1);
      frontCamera.lookAt(0, 0.5, 0);
      renderer.render(scene, frontCamera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 0, 0, width, height);
      pdf.setLineWidth(0.05);
      pdf.line(1, height - 2, 1 + 1, height - 2);
      pdf.setFontSize(8);
      pdf.text('100 cm', 1, height - 1.5);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Vue de face', width / 2, height - 1, { align: 'center' });
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.text('Wall Simulateur 3d', width - 3, height - 1.5, { align: 'right' });
      pdf.text('Made by Julien BROHEZ', width - 3, height - 1, { align: 'right' });
      scene.remove(frontLine);

      // Page 3: Side view
      pdf.addPage();
      const sideLineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, -2),
        new THREE.Vector3(0, 0, 2)
      ]);
      const sideLineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 5 });
      const sideLine = new THREE.Line(sideLineGeometry, sideLineMaterial);
      scene.add(sideLine);
      scene.background = null;
      const sideCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 100);
      sideCamera.position.set(1, 0.5, 0);
      sideCamera.lookAt(0, 0.5, 0);
      renderer.render(scene, sideCamera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 0, 0, width, height);
      pdf.setLineWidth(0.05);
      pdf.line(1, height - 2, 1 + 1, height - 2);
      pdf.setFontSize(8);
      pdf.text('100 cm', 1, height - 1.5);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Vue de c√¥t√©', width / 2, height - 1, { align: 'center' });
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.text('Wall Simulateur 3d', width - 3, height - 1.5, { align: 'right' });
      pdf.text('Made by Julien BROHEZ', width - 3, height - 1, { align: 'right' });
      scene.remove(sideLine);

      // Page 4: 3D view
      pdf.addPage();
      renderer.shadowMap.enabled = true;
      scene.background = skyTexture;
      camera.aspect = exportWidth / exportHeight;
      camera.updateProjectionMatrix();
      camera.lookAt(controls.target);
      renderer.render(scene, camera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 0, 0, width, height);
      pdf.setLineWidth(0.05);
      pdf.line(1, height - 2, 1 + 1, height - 2);
      pdf.setFontSize(8);
      pdf.text('100 cm', 1, height - 1.5);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Vue 3D', width / 2, height - 1, { align: 'center' });
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.text('Wall Simulateur 3d', width - 3, height - 1.5, { align: 'right' });
      pdf.text('Made by Julien BROHEZ', width - 3, height - 1, { align: 'right' });

      // Page 5: Brick inventory
      pdf.addPage();
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Inventaire des briques', width / 2, 1, { align: 'center' });
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(10);
      let y = 2;
      Object.keys(BRICK_SIZES).forEach(type => {
        const count = layers.flat().filter(b => b[3] === type).length;
        pdf.text(`${type}: ${count} briques`, 1, y);
        y += 1;
      });

      renderer.setSize(originalWidth, originalHeight);
      camera.aspect = originalWidth / originalHeight;
      camera.updateProjectionMatrix();
      renderer.shadowMap.enabled = true;
      scene.background = skyTexture;
      renderer.setClearColor(0x000000, 0);

      pdf.save('vue-briques.pdf');
    }

    // Export PNG
    function exportPNG() {
      renderer.render(scene, camera);
      setTimeout(() => {
        const link = document.createElement('a');
        link.download = 'vue-briques.png';
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();
      }, 100);
    }

    // Update Layer Select
    function updateLayerSelect() {
      const select = document.getElementById('layer-select');
      select.innerHTML = '';
      layers.forEach((_, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Assise ${i + 1}`;
        if (i === currentLayer) option.selected = true;
        select.appendChild(option);
      });
    }

    // Drag Handling
    function makeDraggable(element, pos) {
      let isDragging = false;
      let startX, startY;

      element.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'LABEL' || e.target.classList.contains('brick-count')) return;
        isDragging = true;
        startX = e.clientX - pos.x;
        startY = e.clientY - pos.y;
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        let x = e.clientX - startX;
        let y = e.clientY - startY;

        if (element.id === 'layerbox') {
          y = Math.max(100, Math.min(y, 150));
          x = Math.max(0, Math.min(x, window.innerWidth - element.offsetWidth));
        }

        pos.x = x;
        pos.y = y;
        element.style.left = `${x}px`;
        element.style.top = `${y}px`;
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    }

    // Save File
    function saveFile() {
      const data = JSON.stringify(layers);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'wall-design.json';
      link.click();
      URL.revokeObjectURL(url);
    }

    // Open File
    function openFile() {
      document.getElementById('file-input').click();
    }

    function validateLayers(data) {
      return Array.isArray(data) && data.every(layer => Array.isArray(layer) && layer.every(([x, y, z, type, rotY]) => 
        typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && 
        BRICK_SIZES[type] && (rotY === undefined || typeof rotY === 'number')
      ));
    }

    // Event Listeners
    function setupEventListeners() {
      document.getElementById('brick-entire').addEventListener('click', () => {
        selectedSize = 'entire';
        updateScene();
      });
      document.getElementById('brick-three_quarter').addEventListener('click', () => {
        selectedSize = 'three_quarter';
        updateScene();
      });
      document.getElementById('brick-half').addEventListener('click', () => {
        selectedSize = 'half';
        updateScene();
      });
      document.getElementById('brick-quarter').addEventListener('click', () => {
        selectedSize = 'quarter';
        updateScene();
      });
      document.getElementById('rotation-y').addEventListener('input', (e) => {
        rotationY = (e.target.value * Math.PI) / 180;
        document.getElementById('rotation-value').textContent = `${e.target.value}¬∞`;
        updateScene();
      });
      document.getElementById('joint-thickness').addEventListener('input', (e) => {
        jointThickness = parseFloat(e.target.value) / 100;
        updateScene();
      });
      document.getElementById('show-colors').addEventListener('change', (e) => {
        showColors = e.target.checked;
        updateScene();
      });
      document.getElementById('white-bricks').addEventListener('change', (e) => {
        whiteBricks = e.target.checked;
        updateScene();
      });
      document.getElementById('show-grid').addEventListener('change', (e) => {
        gridHelper.visible = e.target.checked;
        renderer.render(scene, camera);
      });
      document.getElementById('layer-select').addEventListener('change', (e) => {
        currentLayer = parseInt(e.target.value);
        updateScene();
      });
      document.getElementById('add-layer').addEventListener('click', addLayer);
      document.getElementById('undo').addEventListener('click', undo);
      document.getElementById('redo').addEventListener('click', redo);
      document.getElementById('delete-mode').addEventListener('click', () => {
        deleteMode = !deleteMode;
        document.getElementById('delete-mode').classList.toggle('delete-active', deleteMode);
        updateScene();
      });
      document.getElementById('save-file').addEventListener('click', saveFile);
      document.getElementById('open-file').addEventListener('click', openFile);
      document.getElementById('file-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const loadedLayers = JSON.parse(event.target.result);
            if (validateLayers(loadedLayers)) {
              layers = loadedLayers;
              currentLayer = Math.min(currentLayer, layers.length - 1);
              history = [{ layers: JSON.parse(JSON.stringify(layers)) }];
              historyIndex = 0;
              console.log('History reset after file load:', history);
              updateLayerSelect();
              updateScene();
            } else {
              console.error('Invalid file format');
              const notification = document.getElementById('notification');
              notification.textContent = 'Erreur : Format de fichier invalide';
              notification.style.left = `${window.innerWidth / 2}px`;
              notification.style.top = `${window.innerHeight / 2}px`;
              notification.style.display = 'block';
              setTimeout(() => notification.style.display = 'none', 2000);
            }
          } catch (err) {
            console.error('Error parsing file:', err);
            const notification = document.getElementById('notification');
            notification.textContent = 'Erreur : Impossible de lire le fichier';
            notification.style.left = `${window.innerWidth / 2}px`;
            notification.style.top = `${window.innerHeight / 2}px`;
            notification.style.display = 'block';
            setTimeout(() => notification.style.display = 'none', 2000);
          }
        };
        reader.readAsText(file);
        e.target.value = ''; // Reset file input
      });
      document.getElementById('export-pdf').addEventListener('click', exportPDF);
      document.getElementById('export-png').addEventListener('click', exportPNG);

      document.addEventListener('mousemove', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(plane);
        if (intersects.length > 0 && !deleteMode) {
          hoverPoint = intersects[0].point;
          console.log('Mouse hover point:', hoverPoint);
        } else {
          hoverPoint = null;
        }
        updateScene();
      });

      renderer.domElement.addEventListener('click', (e) => {
        if (deleteMode) {
          console.log('Click detected in delete mode');
          deleteBrick();
        }
      });

      renderer.domElement.addEventListener('dblclick', (e) => {
        if (!deleteMode) {
          console.log('Double-click detected');
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(plane);
          if (intersects.length > 0) {
            console.log('Plane intersected at:', intersects[0].point);
            addBrick(intersects[0].point);
          } else {
            console.log('No intersection with plane');
          }
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        layerboxPos.x = window.innerWidth / 2 - document.getElementById('layerbox').offsetWidth / 2;
        document.getElementById('layerbox').style.left = `${layerboxPos.x}px`;
      });

      makeDraggable(document.getElementById('layerbox'), layerboxPos);
    }

    // Homepage Button
    document.getElementById('start-button').addEventListener('click', () => {
      document.getElementById('homepage').style.display = 'none';
      document.getElementById('app').style.display = 'block';
      initThreeJS();
      setupEventListeners();
      updateLayerSelect();
      animate();
    });

    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
