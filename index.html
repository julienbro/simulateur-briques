<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wall Simulateur 3d</title>
  <style>
    body { margin: 0; overflow: hidden; background: #ffffff; color: #000000; font-family: Arial, sans-serif; }
    canvas { width: 100%; height: 100vh; }
    .toolbox, .layerbox, .actions, .brick-counter, .title, .version { position: absolute; background: #e2e8f0; padding: 8px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); z-index: 10; }
    .toolbox { top: 10px; left: 10px; width: 256px; }
    .layerbox { top: 100px; left: 50%; transform: translateX(-50%); cursor: move; width: auto; max-width: 600px; display: flex; flex-direction: column; align-items: center; gap: 8px; pointer-events: none; }
    .layerbox * { pointer-events: auto; }
    .actions { top: 10px; right: 10px; width: 256px; }
    .brick-counter { bottom: 10px; right: 10px; width: 200px; }
    .title { top: 10px; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; }
    .title h1 { font-size: 24px; margin: 0; }
    .title p { font-size: 14px; margin: 4px 0 0; }
    .version { bottom: 10px; left: 10px; font-size: 12px; padding: 8px; }
    .grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
    button { padding: 4px; border-radius: 4px; border: none; cursor: pointer; font-size: 12px; font-weight: bold; color: #000000; }
    button:hover { opacity: 0.8; }
    .delete-active { background-color: #b7791f !important; }
    .selected { ring: 2px solid #000000; }
    input, select { background: #edf2f7; color: #000000; border: none; padding: 4px; border-radius: 4px; }
    label { font-size: 14px; margin-right: 8px; }
    h2 { font-size: 18px; margin-bottom: 8px; color: #000000; }
    .brick-count, .brick-type-count { font-size: 14px; }
  </style>
</head>
<body>
  <div id="title" class="title">
    <h1>Wall Simulateur 3d</h1>
    <p>Cr√©√© par Julien BROHEZ</p>
  </div>
  <div id="toolbox" class="toolbox">
    <h2>üß± Outils de pose</h2>
    <label>Type de brique</label>
    <div class="grid">
      <button id="brick-entire" style="background-color: #e07b39;" title="Enti√®re - 19x9x5">1/1</button>
      <button id="brick-three_quarter" style="background-color: #3498db;" title="Trois quarts - 14x9x5">3/4</button>
      <button id="brick-half" style="background-color: #2ecc71;" title="Demi - 9x9x5">1/2</button>
      <button id="brick-quarter" style="background-color: #9b59b6;" title="Quart - 4x9x5">1/4</button>
    </div>
    <label>Rotation Y (¬∞)</label>
    <input type="range" id="rotation-y" min="0" max="355" step="15" value="0">
    <div id="rotation-value" style="text-align: center; font-size: 12px;">0¬∞</div>
    <label>√âpaisseur du joint (cm)</label>
    <input type="number" id="joint-thickness" min="0" step="0.1" value="1">
    <label>Couleur des briques</label>
    <div style="display: flex; align-items: center; gap: 8px;">
      <input type="checkbox" id="show-colors" checked>
      <span style="font-size: 14px;">Afficher les couleurs</span>
    </div>
    <div style="display: flex; align-items: center; gap: 8px; margin-top: 8px;">
      <input type="checkbox" id="white-bricks">
      <span style="font-size: 14px;">Afficher en blanc</span>
    </div>
    <button id="delete-mode" style="background-color: #d69e2e; margin-top: 8px;">üóëÔ∏è Effacer</button>
  </div>
  <div id="layerbox" class="layerbox">
    <div style="display: flex; align-items: center; gap: 12px;">
      <label>Assise active</label>
      <select id="layer-select"></select>
      <button id="add-layer" style="background-color: #3182ce;">‚ûï</button>
    </div>
    <div id="brick-count" class="brick-count" style="margin-top: 8px; text-align: center;">Current Layer: 0 | Total: 0</div>
  </div>
  <div class="actions">
    <h2>üìÑ Actions</h2>
    <button id="undo" style="background-color: #e53e3e;">‚Ü©Ô∏è Annuler</button>
    <button id="export-pdf" style="background-color: #38a169; margin-top: 8px;">üìÑ Exporter PDF</button>
    <button id="export-png" style="background-color: #3182ce; margin-top: 8px;">üñºÔ∏è Exporter PNG</button>
  </div>
  <div id="brick-counter" class="brick-counter">
    <h2>üßÆ Compteur de briques</h2>
    <div id="brick-type-counts" class="brick-type-count">
      <div>Enti√®re: 0</div>
      <div>Trois quarts: 0</div>
      <div>Demi: 0</div>
      <div>Quart: 0</div>
    </div>
  </div>
  <div id="version" class="version">Version 1.0.0</div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    const { jsPDF } = window.jspdf;

    // Constants
    const BRICK_SIZES = {
      entire: [0.19, 0.05, 0.09],
      three_quarter: [0.14, 0.05, 0.09],
      half: [0.09, 0.05, 0.09],
      quarter: [0.04, 0.05, 0.09],
    };
    const COLOR_MAP = {
      entire: '#e07b39',
      three_quarter: '#3498db',
      half: '#2ecc71',
      quarter: '#9b59b6',
    };

    // State
    let layers = [[/* assise 0 */]];
    let currentLayer = 0;
    let selectedSize = 'entire';
    let hoverPoint = null;
    let jointThickness = 0.01;
    let rotationY = 0;
    let showColors = true;
    let whiteBricks = false;
    let deleteMode = false;
    let layerboxPos = { x: window.innerWidth / 2 - 150, y: 100 };

    // Three.js Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0.5, 0.5, 1);
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.shadowMap.autoUpdate = false;
    document.body.appendChild(renderer.domElement);

    // Gradient Sky
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const context = canvas.getContext('2d');
    const gradient = context.createLinearGradient(0, 0, 0, 512);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(1, '#FFFFFF');
    context.fillStyle = gradient;
    context.fillRect(0, 0, 512, 512);
    const skyTexture = new THREE.CanvasTexture(canvas);
    scene.background = skyTexture;

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(1, 2, 2);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.left = -2;
    directionalLight.shadow.camera.right = 2;
    directionalLight.shadow.camera.top = 2;
    directionalLight.shadow.camera.bottom = -2;
    directionalLight.shadow.camera.near = 0.1;
    directionalLight.shadow.camera.far = 10;
    scene.add(directionalLight);

    // Controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = true;
    controls.enableZoom = true;
    controls.enableRotate = true;

    // Ground Plane (Visible Floor)
    const planeGeometry = new THREE.PlaneGeometry(4, 4);
    const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xf0f0f0, visible: true });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;
    scene.add(plane);

    // Shadow Plane
    const shadowMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
    const shadowPlane = new THREE.Mesh(planeGeometry, shadowMaterial);
    shadowPlane.rotation.x = -Math.PI / 2;
    shadowPlane.receiveShadow = true;
    scene.add(shadowPlane);

    // Raycaster for mouse interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // Create Brick
    function createBrick(position, size, type, transparent = false, highlight = false, rotation = [0, 0, 0]) {
      const geometry = new THREE.BoxGeometry(...size);
      const color = whiteBricks ? '#ffffff' : (highlight ? '#00ffff' : (showColors ? (COLOR_MAP[type] || 'orange') : '#999'));
      const material = new THREE.MeshStandardMaterial({
        color,
        transparent,
        opacity: transparent ? 0.3 : 1,
        wireframe: transparent,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(...position);
      mesh.rotation.set(...rotation);
      mesh.castShadow = !transparent;
      mesh.receiveShadow = true;

      // Add edges for placed bricks
      if (!transparent) {
        const edges = new THREE.EdgesGeometry(geometry);
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });
        const edgeLines = new THREE.LineSegments(edges, edgeMaterial);
        edgeLines.position.set(...position);
        edgeLines.rotation.set(...rotation);
        mesh.userData.edges = edgeLines;
      }

      return mesh;
    }

    // Update Scene Bricks
    function updateScene() {
      scene.children = scene.children.filter(child => !child.isMesh && !child.isLineSegments || child === plane || child === shadowPlane);
      let hoveredBrick = null;
      if (deleteMode) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children.filter(child => child.isMesh && child !== plane && child !== shadowPlane));
        if (intersects.length > 0) {
          hoveredBrick = intersects[0].object;
        }
      }
      layers.flat().forEach(([x, y, z, type, rotY]) => {
        const isHovered = deleteMode && hoveredBrick && Math.abs(hoveredBrick.position.x - x) < 0.001 && Math.abs(hoveredBrick.position.y - y) < 0.001 && Math.abs(hoveredBrick.position.z - z) < 0.001;
        const brick = createBrick([x, y, z], BRICK_SIZES[type], type, false, isHovered, [0, rotY || 0, 0]);
        scene.add(brick);
        if (brick.userData.edges) scene.add(brick.userData.edges);
      });
      if (hoverPoint && !deleteMode && hoverPoint.x !== undefined && hoverPoint.z !== undefined) {
        let snapX = Math.round(hoverPoint.x * 100) / 100;
        let snapZ = Math.round(hoverPoint.z * 100) / 100;
        const threshold = jointThickness + 0.001;
        const allPositions = layers.flat();
        for (const [x, , z] of allPositions) {
          if (Math.abs(snapX - x) <= threshold) snapX = x;
          if (Math.abs(snapZ - z) <= threshold) snapZ = z;
        }
        console.log('Hover brick position:', { snapX, snapZ });
        const y = getBrickY(BRICK_SIZES[selectedSize]);
        const hoverBrick = createBrick([snapX, y, snapZ], BRICK_SIZES[selectedSize], selectedSize, true, false, [0, rotationY, 0]);
        scene.add(hoverBrick);
      } else {
        console.log('Hover point invalid:', hoverPoint);
      }
      updateBrickCount();
      renderer.shadowMap.needsUpdate = true;
    }

    // Update Brick Count
    function updateBrickCount() {
      const currentCount = layers[currentLayer].length;
      const totalCount = layers.reduce((sum, layer) => sum + layer.length, 0);
      document.getElementById('brick-count').textContent = `Current Layer: ${currentCount} | Total: ${totalCount}`;

      // Update brick type counts
      const counts = {
        entire: layers.flat().filter(b => b[3] === 'entire').length,
        three_quarter: layers.flat().filter(b => b[3] === 'three_quarter').length,
        half: layers.flat().filter(b => b[3] === 'half').length,
        quarter: layers.flat().filter(b => b[3] === 'quarter').length,
      };
      document.getElementById('brick-type-counts').innerHTML = `
        <div>Enti√®re: ${counts.entire}</div>
        <div>Trois quarts: ${counts.three_quarter}</div>
        <div>Demi: ${counts.half}</div>
        <div>Quart: ${counts.quarter}</div>
      `;
    }

    // Get Brick Y Position
    function getBrickY(size) {
      return size[1] / 2 + jointThickness + currentLayer * (size[1] + jointThickness);
    }

    // Add Brick
    function addBrick(point) {
      if (!point || point.x === undefined || point.z === undefined) {
        console.error('Invalid point for addBrick:', point);
        return;
      }
      const allPositions = layers.flat();
      const threshold = jointThickness + 0.001;
      const size = BRICK_SIZES[selectedSize];
      let snappedX = Math.round(point.x * 100) / 100;
      let snappedZ = Math.round(point.z * 100) / 100;

      for (const [x, , z] of allPositions) {
        if (Math.abs(snappedX - x) <= threshold) snappedX = x;
        if (Math.abs(snappedZ - z) <= threshold) snappedZ = z;
      }

      const y = getBrickY(size);
      console.log('Adding brick at:', { snappedX, y, snappedZ });
      layers[currentLayer].push([snappedX, y, snappedZ, selectedSize, rotationY]);
      updateScene();
    }

    // Delete Brick
    function deleteBrick() {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children.filter(child => child.isMesh && child !== plane && child !== shadowPlane));
      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const position = clickedMesh.position;
        for (let i = 0; i < layers.length; i++) {
          layers[i] = layers[i].filter(([x, y, z]) => {
            return !(Math.abs(x - position.x) < 0.001 && Math.abs(y - position.y) < 0.001 && Math.abs(z - position.z) < 0.001);
          });
        }
        deleteMode = false;
        document.getElementById('delete-mode').classList.remove('delete-active');
        updateScene();
      }
    }

    // Add Layer
    function addLayer() {
      layers.push([]);
      currentLayer = layers.length - 1;
      updateLayerSelect();
      updateScene();
    }

    // Undo
    function undo() {
      layers[currentLayer] = layers[currentLayer].slice(0, -1);
      updateScene();
    }

    // Export PDF
    function exportPDF() {
      const originalWidth = window.innerWidth;
      const originalHeight = window.innerHeight;
      const exportWidth = 1920;
      const exportHeight = exportWidth * (originalHeight / originalWidth);

      const pdf = new jsPDF({ orientation: 'landscape', unit: 'cm', format: [21, 29.7] });
      const width = pdf.internal.pageSize.getWidth();
      const height = pdf.internal.pageSize.getHeight();

      renderer.setSize(exportWidth, exportHeight);
      renderer.setClearColor(0xffffff, 1);

      // Page 1: Top view (Orthographic, dynamic scale)
      let minX = 0, maxX = 0, minZ = 0, maxZ = 0;
      layers.flat().forEach(([x, , z]) => {
        minX = Math.min(minX, x - 0.19 / 2);
        maxX = Math.max(maxX, x + 0.19 / 2);
        minZ = Math.min(minZ, z - 0.19 / 2);
        maxZ = Math.max(maxZ, z + 0.19 / 2);
      });
      const padding = 0.1;
      const topWidth = Math.max(2, maxX - minX + padding);
      const topHeight = Math.max(2, maxZ - minZ + padding);
      renderer.shadowMap.enabled = false;
      scene.background = null;
      const topCamera = new THREE.OrthographicCamera(-topWidth / 2, topWidth / 2, topHeight / 2, -topHeight / 2, 0.1, 100);
      topCamera.position.set(0, 1, 0);
      topCamera.lookAt(0, 0, 0);
      renderer.render(scene, topCamera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 0, 0, width, height);
      pdf.setLineWidth(0.05);
      pdf.line(1, height - 2, 1 + 1, height - 2);
      pdf.setFontSize(8);
      pdf.text('100 cm', 1, height - 1.5);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Vue de dessus', width / 2, height - 1, { align: 'center' });
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.text('Wall Simulateur 3d', width - 3, height - 1.5, { align: 'right' });
      pdf.text('Made by Julien BROHEZ', width - 3, height - 1, { align: 'right' });

      // Page 2: Front view (Orthographic, 2x scale, with ground line)
      pdf.addPage();
      const frontLineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-2, 0, 0),
        new THREE.Vector3(2, 0, 0)
      ]);
      const frontLineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 5 });
      const frontLine = new THREE.Line(frontLineGeometry, frontLineMaterial);
      scene.add(frontLine);
      scene.background = null;
      const frontCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 100);
      frontCamera.position.set(0, 0.5, 1);
      frontCamera.lookAt(0, 0.5, 0);
      renderer.render(scene, frontCamera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 0, 0, width, height);
      pdf.setLineWidth(0.05);
      pdf.line(1, height - 2, 1 + 1, height - 2);
      pdf.setFontSize(8);
      pdf.text('100 cm', 1, height - 1.5);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Vue de face', width / 2, height - 1, { align: 'center' });
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.text('Wall Simulateur 3d', width - 3, height - 1.5, { align: 'right' });
      pdf.text('Made by Julien BROHEZ', width - 3, height - 1, { align: 'right' });
      scene.remove(frontLine);

      // Page 3: Side view (Orthographic, 2x scale, with ground line)
      pdf.addPage();
      const sideLineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, -2),
        new THREE.Vector3(0, 0, 2)
      ]);
      const sideLineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 5 });
      const sideLine = new THREE.Line(sideLineGeometry, sideLineMaterial);
      scene.add(sideLine);
      scene.background = null;
      const sideCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 100);
      sideCamera.position.set(1, 0.5, 0);
      sideCamera.lookAt(0, 0.5, 0);
      renderer.render(scene, sideCamera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 0, 0, width, height);
      pdf.setLineWidth(0.05);
      pdf.line(1, height - 2, 1 + 1, height - 2);
      pdf.setFontSize(8);
      pdf.text('100 cm', 1, height - 1.5);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Vue de c√¥t√©', width / 2, height - 1, { align: 'center' });
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.text('Wall Simulateur 3d', width - 3, height - 1.5, { align: 'right' });
      pdf.text('Made by Julien BROHEZ', width - 3, height - 1, { align: 'right' });
      scene.remove(sideLine);

      // Page 4: 3D view (Perspective, current viewpoint)
      pdf.addPage();
      renderer.shadowMap.enabled = true;
      scene.background = skyTexture;
      camera.aspect = exportWidth / exportHeight;
      camera.updateProjectionMatrix();
      camera.lookAt(controls.target);
      renderer.render(scene, camera);
      pdf.addImage(renderer.domElement.toDataURL('image/png'), 'PNG', 0, 0, width, height);
      pdf.setLineWidth(0.05);
      pdf.line(1, height - 2, 1 + 1, height - 2);
      pdf.setFontSize(8);
      pdf.text('100 cm', 1, height - 1.5);
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Vue 3D', width / 2, height - 1, { align: 'center' });
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.text('Wall Simulateur 3d', width - 3, height - 1.5, { align: 'right' });
      pdf.text('Made by Julien BROHEZ', width - 3, height - 1, { align: 'right' });

      // Page 5: Brick inventory
      pdf.addPage();
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Inventaire des briques', width / 2, 1, { align: 'center' });
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(10);
      let y = 2;
      Object.keys(BRICK_SIZES).forEach(type => {
        const count = layers.flat().filter(b => b[3] === type).length;
        pdf.text(`${type}: ${count} briques`, 1, y);
        y += 1;
      });

      renderer.setSize(originalWidth, originalHeight);
      camera.aspect = originalWidth / originalHeight;
      camera.updateProjectionMatrix();
      renderer.shadowMap.enabled = true;
      scene.background = skyTexture;
      renderer.setClearColor(0x000000, 0);

      pdf.save('vue-briques.pdf');
    }

    // Export PNG
    function exportPNG() {
      renderer.render(scene, camera);
      setTimeout(() => {
        const link = document.createElement('a');
        link.download = 'vue-briques.png';
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();
      }, 100);
    }

    // Update Layer Select
    function updateLayerSelect() {
      const select = document.getElementById('layer-select');
      select.innerHTML = '';
      layers.forEach((_, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Assise ${i + 1}`;
        if (i === currentLayer) option.selected = true;
        select.appendChild(option);
      });
    }

    // Drag Handling
    function makeDraggable(element, pos) {
      let isDragging = false;
      let startX, startY;

      element.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'LABEL' || e.target.classList.contains('brick-count')) return;
        isDragging = true;
        startX = e.clientX - pos.x;
        startY = e.clientY - pos.y;
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        let x = e.clientX - startX;
        let y = e.clientY - startY;

        if (element.id === 'layerbox') {
          y = Math.max(100, Math.min(y, 150));
          x = Math.max(0, Math.min(x, window.innerWidth - element.offsetWidth));
        }

        pos.x = x;
        pos.y = y;
        element.style.left = `${x}px`;
        element.style.top = `${y}px`;
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    }

    // Event Listeners
    document.getElementById('brick-entire').addEventListener('click', () => {
      selectedSize = 'entire';
      updateScene();
    });
    document.getElementById('brick-three_quarter').addEventListener('click', () => {
      selectedSize = 'three_quarter';
      updateScene();
    });
    document.getElementById('brick-half').addEventListener('click', () => {
      selectedSize = 'half';
      updateScene();
    });
    document.getElementById('brick-quarter').addEventListener('click', () => {
      selectedSize = 'quarter';
      updateScene();
    });
    document.getElementById('rotation-y').addEventListener('input', (e) => {
      rotationY = (e.target.value * Math.PI) / 180;
      document.getElementById('rotation-value').textContent = `${e.target.value}¬∞`;
      updateScene();
    });
    document.getElementById('joint-thickness').addEventListener('input', (e) => {
      jointThickness = parseFloat(e.target.value) / 100;
      updateScene();
    });
    document.getElementById('show-colors').addEventListener('change', (e) => {
      showColors = e.target.checked;
      updateScene();
    });
    document.getElementById('white-bricks').addEventListener('change', (e) => {
      whiteBricks = e.target.checked;
      updateScene();
    });
    document.getElementById('layer-select').addEventListener('change', (e) => {
      currentLayer = parseInt(e.target.value);
      updateScene();
    });
    document.getElementById('add-layer').addEventListener('click', addLayer);
    document.getElementById('undo').addEventListener('click', undo);
    document.getElementById('delete-mode').addEventListener('click', () => {
      deleteMode = !deleteMode;
      document.getElementById('delete-mode').classList.toggle('delete-active', deleteMode);
      updateScene();
    });
    document.getElementById('export-pdf').addEventListener('click', exportPDF);
    document.getElementById('export-png').addEventListener('click', exportPNG);

    // Mouse Move for Hover
    document.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(plane);
      if (intersects.length > 0 && !deleteMode) {
        hoverPoint = intersects[0].point;
        console.log('Mouse hover point:', hoverPoint);
      } else {
        hoverPoint = null;
      }
      updateScene();
    });

    // Click to Add or Delete Brick
    renderer.domElement.addEventListener('click', (e) => {
      if (deleteMode) {
        console.log('Click detected in delete mode');
        deleteBrick();
      }
    });

    // Double Click to Add Brick
    renderer.domElement.addEventListener('dblclick', (e) => {
      if (!deleteMode) {
        console.log('Double-click detected');
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(plane);
        if (intersects.length > 0) {
          console.log('Plane intersected at:', intersects[0].point);
          addBrick(intersects[0].point);
        } else {
          console.log('No intersection with plane');
        }
      }
    });

    // Window Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      layerboxPos.x = window.innerWidth / 2 - document.getElementById('layerbox').offsetWidth / 2;
      document.getElementById('layerbox').style.left = `${layerboxPos.x}px`;
    });

    // Draggable Layerbox
    makeDraggable(document.getElementById('layerbox'), layerboxPos);

    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Initial Layer Select
    updateLayerSelect();
  </script>
</body>
</html>
